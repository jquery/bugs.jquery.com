<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-pagefind-meta="title">#7389 (change .selector property into .selectors array) - jQuery - Bug Tracker</title>
    <meta name="description" content="Static archive of the old bugs.jquery.com Trac site.">
    
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="/bundle/SEeiGkT-TJ.css">
  </head>
  <body>
    <div class="banner flex-center">
      <span>jQuery issues have moved to <a href="https://github.com/jquery/jquery/issues">GitHub</a>. This site is now a static archive of the old <a href="https://trac.edgewall.org/">Trac</a> bugs site. Some functions and pages are no longer available.</span>
    </div>
    <div class="container">
      <a href="#skip" class="visually-hidden">Skip to main content</a>
      <header class="flex-column">
        <div class="flex-row flex-between-start">
          <a id="jq-siteLogo" href="/" title="jQuery Home">
            <img src="/img/logo.svg" width="215" alt="jQuery: Write Less, Do More.">
          </a>
          <input class="hamburger-toggle visually-hidden" id="jq-menutoggle" type="checkbox">
          <label aria-label="Toggle Menu" for="jq-menutoggle" class="hamburger-lines flex-column flex-between-center">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </label>
          <div id="jq-menus">
            <nav id="jq-primaryNavigation">
              <h2 class="visually-hidden">jQuery sites navigation menu</h2>
              <ul class="nav">
                <li class="jq-jquery active">
                  <a href="https://jquery.com/" title="jQuery Home">jQuery</a>
                </li>
                <li class="jq-plugins">
                  <a href="https://plugins.jquery.com/" title="jQuery Plugins">Plugins</a>
                </li>
                <li class="jq-ui">
                  <a href="https://jqueryui.com/" title="jQuery UI">UI</a>
                </li>
                <li class="jq-meetup">
                  <a href="https://meetups.jquery.com/" title="jQuery Meetups">Meetups</a>
                </li>
                <li class="jq-forum">
                  <a href="https://forum.jquery.com/" title="jQuery Forum">Forum</a>
                </li>
                <li class="jq-blog">
                  <a href="https://blog.jquery.com/" title="jQuery Blog">Blog</a>
                </li>
                <li class="jq-about">
                  <a href="https://openjsf.org" title="About jQuery and OpenJS">About</a>
                </li>
                <li class="jq-donate">
                  <a href="https://openjsf.org/about/project-funding-opportunities/" title="Donate to OpenJS">Donate</a>
                </li>
              </ul>
            </nav>
            <nav id="jq-secondaryNavigation">
              <h2 class="visually-hidden">jQuery Core navigation menu</h2>
              <ul class="nav">
                <li class="jq-download">
                  <a href="https://jquery.com/download/">
                    Download
                  </a>
                </li>
                <li class="jq-documentation">
                  <a href="https://api.jquery.com/">
                    Documentation
                  </a>
                </li>
                <li class="jq-tutorials">
                  <a href="https://learn.jquery.com/">
                    Tutorials
                  </a>
                </li>
                <li class="jq-bugTracker">
                  <a href="https://github.com/jquery/jquery/issues">
                    Bug Tracker
                  </a>
                </li>
                <li class="jq-discussion">
                  <a href="https://forum.jquery.com/">
                    Discussion
                  </a>
                </li>
              </ul>
            </nav>
          </div>
        </div>
        <div id="bug-tracker-form" class="flex-column flex-between-center">
          <h1>Bug Tracker</h1>
          <div id="search"></div>
          
        </div>
      </header>
      <main id="skip" class="flex-column">
        <h2 class="visually-hidden">Side navigation</h2>
        <nav id="jq-sidenav" class="flex-column white-box">
          <h5 class="sidenav-header">Bug Tracker</h5>
          <a href="/newticket">New Ticket</a>
          <a href="/report">View Tickets</a>
          <a href="/ticketgraph">Ticket Graph</a>
          <a href="/roadmap">Roadmap</a>
          <a href="/timeline">Recent Changes</a>
        </nav>
        <div id="jq-content" class="white-box">
          

<div class="flex-column" data-pagefind-body="">
  

  <nav class="content-nav">
    <ul class="flex-row">
      
        <li>
          <a href="/ticket/7388/">← Previous Ticket</a>
        
      
      
        </li><li>
          <a href="/ticket/7390/">Next Ticket →</a>
        </li>
      
    </ul>
  </nav>


<div class="ticket-info">
  <div class="flex-row flex-between-start">
    <h3>
      <a href="" class="ticket-number">#7389</a>
      <span class="ticket-status">closed</span>
      <span class="ticket-type">enhancement</span>
      <span class="ticket-resolution">(wontfix)</span>
    </h3>

    <div class="ticket-dates">
      <p>Opened November 03, 2010 02:52PM UTC</p>
      
        <p>Closed July 12, 2011 03:01PM UTC</p>
      
      
        <p>Last modified March 13, 2012 03:20PM UTC</p>
      
    </div>
  </div>

  <h1 class="ticket-title">change .selector property into .selectors array</h1>

  <table class="ticket-properties">
    <tr>
      <th>Reported by:</th>
      <td>
        cowboy
      </td>
      <th>Owned by:</th>
      <td></td>
    </tr>
    <tr>
      <th>
        Priority:
      </th>
      <td>
        low
      </td>
      
        <th class="missing">Milestone:</th>
      
      <td>
        <a href="/milestone/1.next">1.next</a>
      </td>
    </tr>
    <tr>
      <th>Component:</th>
      <td>selector</td>
      
        <th>Version:</th>
      
      <td>1.4.3</td>
    </tr>
    <tr>
      
        <th>Keywords:</th>
      
      <td>1.7-discuss</td>
      
        <th class="missing">Cc:</th>
      
      <td></td>
    </tr>
    <tr>
      <th class="missing">
        Blocked by:
      </th>
      <td></td>
      <th class="missing">
        Blocking:
      </th>
      <td></td>
    </tr>
  </table>
  <div class="ticket-info-bottom">
    <h5 class="ticket-description-title">Description</h5>
    <div class="ticket-description"><p>I'm just throwing this out there, but based on questions I've received from people in the past and ticket <a href="/ticket/6754">#6754</a>, I think it's potentially problematic for the <code>.selector</code> property to be a concatenated string of all previous selector strings / derived selectors, because people might think it's supposed to be a valid selector they can use to actually select elements.</p><p>In fact, other than for events, I don't see the value in the current <code>.selector</code> property's value, and even then, it's useless once any kind of complex traversing/filtering has taken place.</p><p>I propose that the <code>.selector</code> string property be changed to a <code>.selectors</code> array property, with the <code>.selector</code> property reflecting the last *actual* selector string used. For example:</p><pre class="wiki">
var elems = $('div').children('p');

elems.selector // 'p'
elems.prevObject.selector // 'div'

elems.selectors // [ 'div', '.children(p)' ]
elems.prevObject.selectors // [ 'div' ]
</pre><p>This way, the array could just be joined if someone wants the old (current) behavior, but because it's an array it would allow a more robust programmatic after-the-fact selector parsing logic.</p><p>The <code>.selectors</code> array could even be an array of hashes, like so:</p><pre class="wiki">
var elems = $('div').children('p');

elems.selector // 'p'
elems.prevObject.selector // 'div'

elems.selectors // [ { name: 'jQuery', selector: 'div' }, { name: 'children', selector: 'p' } ]
elems.prevObject.selectors // [ { name: 'jQuery', selector: 'div' } ]
</pre><p>Of course, at this point, since you already have the simple <code>.selector</code> property, you could forgo the array altogether and just add a <code>.methodname</code> property:</p><pre class="wiki">
var elems = $('div').children('p');

elems.selector // 'p'
elems.prevObject.selector // 'div'

elems.methodname // 'children'
elems.prevObject.methodname // 'jQuery'
</pre><p>Either way, a non-string-property-approach might help avoid possible confusion from people who think that the <code>.selector</code> property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.</p></div>
  </div>
</div>

<details>
  <summary class="ticket-details-summary">Attachments (0)</summary>

  <ul class="ticket-attachments">
    
  </ul>
</details>

<details open="">
  <summary class="ticket-details-summary">Change History (18)</summary>
  
    <div class="ticket-change flex-column" id="comment:1">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 03, 2010 06:09PM UTC by <span class="author">snover</span></span>
        <a class="ticket-change-link" href="#comment:1">comment:1</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>owner:</th>
                  <td>
                    
                      <span class="change-field-new">→ cowboy</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">pending</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Other than avoiding any more confusion from people that ignore the documentation (which states “if DOM traversal methods have been called on the object, the string may not be a valid jQuery selector expression”), what sort of use cases are there for providing this?</p>
            </div>
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:2">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 03, 2010 06:43PM UTC by <span class="author">cowboy</span></span>
        <a class="ticket-change-link" href="#comment:2">comment:2</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">pending</span> → <span class="change-field-new">new</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Benefits:</p> <ul><li>a slightly smaller and simpler jQuery</li> <li>less end-user confusion (around both the <code>.selector</code> value and <code>.live</code> method behavior, or even the very simple but unexpected behavior in <a href="/ticket/6754">#6754</a>)</li> <li>with the array of hashes / <code>.methodname</code> property approach, the traversal/filtering methods and selectors used could be programmatically derived without complex string parsing</li></ul>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:3">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 03, 2010 08:01PM UTC by <span class="author">SlexAxton</span></span>
        <a class="ticket-change-link" href="#comment:3">comment:3</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>component:</th>
                  <td>
                    
                      <span class="change-field-old">unfiled</span> → <span class="change-field-new">selector</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>priority:</th>
                  <td>
                    
                      <span class="change-field-old">undecided</span> → <span class="change-field-new">low</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">open</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I think it's pretty fair to say that the current behavior doesn't make sense in a lot of common cases. In the case of just string concatenated dom traversal stuff, it's completely useless. I think, while this is largely unimportant since no one should be relying on the .selector property, that it couldn't hurt to consider it in a future build, just so we have something that can at least be consistent.</p>
            </div>
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:4">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 04, 2010 12:02AM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:4">comment:4</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Hmmm, I didn't even think we documented </p><pre class="wiki">.selector</pre> publicly, but why the heck are people trying to look at it? We know it doesn't survive complex traversal or filtering methods. Saying "don't touch that" in the docs saves us the code of trying to fix it and still falling short.<p></p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:5">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 13, 2010 11:51AM UTC by <span class="author">cowboy</span></span>
        <a class="ticket-change-link" href="#comment:5">comment:5</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>The <code>.selector</code> property is <a href="http://api.jquery.com/category/plugin-authoring/" class="ext-link"><span class="icon"></span>documented here</a> and has been for quite some time, IIRC.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:6">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 16, 2011 10:40PM UTC by <span class="author">john</span></span>
        <a class="ticket-change-link" href="#comment:6">comment:6</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>milestone:</th>
                  <td>
                    
                      <span class="change-field-new">→ 1.7</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>owner:</th>
                  <td>
                    
                      <span class="change-field-old strikethrough">cowboy</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">open</span> → <span class="change-field-new">assigned</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Let's look at this for 1.7.</p>
            </div>
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:7">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 16, 2011 10:59PM UTC by <span class="author">john</span></span>
        <a class="ticket-change-link" href="#comment:7">comment:7</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>milestone:</th>
                  <td>
                    
                      <span class="change-field-old">1.7</span> → <span class="change-field-new">1.next</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:8">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed May 22, 2011 07:27PM UTC by <span class="author">john</span></span>
        <a class="ticket-change-link" href="#comment:8">comment:8</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>keywords:</th>
                  <td>
                    
                      <span class="change-field-new">→ 1.7-discuss</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Nominating ticket for 1.7 discussion.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:9">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed May 22, 2011 09:38PM UTC by <span class="author">rwaldron</span></span>
        <a class="ticket-change-link" href="#comment:9">comment:9</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, A huge burden that will require managing entries to the array... which means all existing methods would have to bear the addition of at least one function being added to their call stack. -9001</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:10">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed May 23, 2011 12:20AM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:10">comment:10</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, sounds like a cheap and horrible way to construct selection... and a means to actually do terribly wrong things in general</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:11">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed May 23, 2011 03:58AM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:11">comment:11</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, might make selector more useful, but entirely unnecessary.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:12">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed May 31, 2011 04:21PM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:12">comment:12</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, Not a fan of <code>.selector</code> at all.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:13">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 03, 2011 01:43PM UTC by <span class="author">john</span></span>
        <a class="ticket-change-link" href="#comment:13">comment:13</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1, I like this - it makes what we originally wanted to do with .selector actually possible (do all sorts of after-the-fact stack manipulation). This would be a very easy change given that we already handle all of this in pushStack.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:14">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 03, 2011 03:19PM UTC by <span class="author">cowboy</span></span>
        <a class="ticket-change-link" href="#comment:14">comment:14</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I'd encourage everyone to look at <a href="/ticket/9469">#9469</a> and then from there, continue discussion of the <code>.selector</code> property. I think combining the ideas from that ticket with this one might be the best approach.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:15">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 03, 2011 03:36PM UTC by <span class="author">scottgonzalez</span></span>
        <a class="ticket-change-link" href="#comment:15">comment:15</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+0, no opinion, this is all internal, right?</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:16">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 05, 2011 09:00PM UTC by <span class="author">ajpiano</span></span>
        <a class="ticket-change-link" href="#comment:16">comment:16</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, I like the idea of dropping this in <a href="/ticket/9469">#9469</a> and I definitely don't think we should spend our cycles working on getting this "right" if it's impossible.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:17">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 06, 2011 03:58PM UTC by <span class="author">jzaefferer</span></span>
        <a class="ticket-change-link" href="#comment:17">comment:17</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+0</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:18">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed July 12, 2011 03:01PM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:18">comment:18</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span> → <span class="change-field-new">I&#39;m just throwing this out there, but based on questions I&#39;ve received from people in the past and ticket #6754, I think it&#39;s potentially problematic for the `.selector` property to be a concatenated string of all previous selector strings / derived selectors, because people might think it&#39;s supposed to be a valid selector they can use to actually select elements.&#92;
&#92;
In fact, other than for events, I don&#39;t see the value in the current `.selector` property&#39;s value, and even then, it&#39;s useless once any kind of complex traversing/filtering has taken place.&#92;
&#92;
I propose that the `.selector` string property be changed to a `.selectors` array property, with the `.selector` property reflecting the last *actual* selector string used. For example:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ &#39;div&#39;, &#39;.children(p)&#39; ]&#92;
elems.prevObject.selectors // [ &#39;div&#39; ]&#92;
}}}&#92;
&#92;
This way, the array could just be joined if someone wants the old (current) behavior, but because it&#39;s an array it would allow a more robust programmatic after-the-fact selector parsing logic.&#92;
&#92;
The `.selectors` array could even be an array of hashes, like so:&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; }, { name: &#39;children&#39;, selector: &#39;p&#39; } ]&#92;
elems.prevObject.selectors // [ { name: &#39;jQuery&#39;, selector: &#39;div&#39; } ]&#92;
}}}&#92;
&#92;
Of course, at this point, since you already have the simple `.selector` property, you could forgo the array altogether and just add a `.methodname` property:&#92;
&#92;
{{{&#92;
var elems = $(&#39;div&#39;).children(&#39;p&#39;);&#92;
&#92;
elems.selector // &#39;p&#39;&#92;
elems.prevObject.selector // &#39;div&#39;&#92;
&#92;
elems.methodname // &#39;children&#39;&#92;
elems.prevObject.methodname // &#39;jQuery&#39;&#92;
}}}&#92;
&#92;
Either way, a non-string-property-approach might help avoid possible confusion from people who think that the `.selector` property is always a valid selector string they can use in a new selection, and might add some value to being able to better programmatically derive selectors from sequential complex/filtering operations.&#92;
</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>resolution:</th>
                  <td>
                    
                      <span class="change-field-new">→ wontfix</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">assigned</span> → <span class="change-field-new">closed</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Per the 1.7 vote this isn't going to be implemented.</p>
            </div>
          
        
          
        
          
        
          
        
      </div>
    </div>
  
</details>
</div>
        </div>
      </main>
      <footer>
        Copyright &copy; 2024
        <a href="https://openjsf.org">The OpenJS Foundation</a>
      </footer>
    </div>
    <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
  </body>
</html>
