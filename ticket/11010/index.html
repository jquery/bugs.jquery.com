<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-pagefind-meta="title">#11010 (Make Deferred.then == Deferred.pipe like Promise/A) - jQuery - Bug Tracker</title>
    <meta name="description" content="Static archive of the old bugs.jquery.com Trac site.">
    
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="/bundle/SEeiGkT-TJ.css">
  </head>
  <body>
    <div class="banner flex-center">
      <span>jQuery issues have moved to <a href="https://github.com/jquery/jquery/issues">GitHub</a>. This site is now a static archive of the old <a href="https://trac.edgewall.org/">Trac</a> bugs site. Some functions and pages are no longer available.</span>
    </div>
    <div class="container">
      <a href="#skip" class="visually-hidden">Skip to main content</a>
      <header class="flex-column">
        <div class="flex-row flex-between-start">
          <a id="jq-siteLogo" href="/" title="jQuery Home">
            <img src="/img/logo.svg" width="215" alt="jQuery: Write Less, Do More.">
          </a>
          <input class="hamburger-toggle visually-hidden" id="jq-menutoggle" type="checkbox">
          <label aria-label="Toggle Menu" for="jq-menutoggle" class="hamburger-lines flex-column flex-between-center">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </label>
          <div id="jq-menus">
            <nav id="jq-primaryNavigation">
              <h2 class="visually-hidden">jQuery sites navigation menu</h2>
              <ul class="nav">
                <li class="jq-jquery active">
                  <a href="https://jquery.com/" title="jQuery Home">jQuery</a>
                </li>
                <li class="jq-plugins">
                  <a href="https://plugins.jquery.com/" title="jQuery Plugins">Plugins</a>
                </li>
                <li class="jq-ui">
                  <a href="https://jqueryui.com/" title="jQuery UI">UI</a>
                </li>
                <li class="jq-meetup">
                  <a href="https://meetups.jquery.com/" title="jQuery Meetups">Meetups</a>
                </li>
                <li class="jq-forum">
                  <a href="https://forum.jquery.com/" title="jQuery Forum">Forum</a>
                </li>
                <li class="jq-blog">
                  <a href="https://blog.jquery.com/" title="jQuery Blog">Blog</a>
                </li>
                <li class="jq-about">
                  <a href="https://openjsf.org" title="About jQuery and OpenJS">About</a>
                </li>
                <li class="jq-donate">
                  <a href="https://openjsf.org/about/project-funding-opportunities/" title="Donate to OpenJS">Donate</a>
                </li>
              </ul>
            </nav>
            <nav id="jq-secondaryNavigation">
              <h2 class="visually-hidden">jQuery Core navigation menu</h2>
              <ul class="nav">
                <li class="jq-download">
                  <a href="https://jquery.com/download/">
                    Download
                  </a>
                </li>
                <li class="jq-documentation">
                  <a href="https://api.jquery.com/">
                    Documentation
                  </a>
                </li>
                <li class="jq-tutorials">
                  <a href="https://learn.jquery.com/">
                    Tutorials
                  </a>
                </li>
                <li class="jq-bugTracker">
                  <a href="https://github.com/jquery/jquery/issues">
                    Bug Tracker
                  </a>
                </li>
                <li class="jq-discussion">
                  <a href="https://forum.jquery.com/">
                    Discussion
                  </a>
                </li>
              </ul>
            </nav>
          </div>
        </div>
        <div id="bug-tracker-form" class="flex-column flex-between-center">
          <h1>Bug Tracker</h1>
          <div id="search"></div>
          
        </div>
      </header>
      <main id="skip" class="flex-column">
        <h2 class="visually-hidden">Side navigation</h2>
        <nav id="jq-sidenav" class="flex-column white-box">
          <h5 class="sidenav-header">Bug Tracker</h5>
          <a href="/newticket">New Ticket</a>
          <a href="/report">View Tickets</a>
          <a href="/ticketgraph">Ticket Graph</a>
          <a href="/roadmap">Roadmap</a>
          <a href="/timeline">Recent Changes</a>
        </nav>
        <div id="jq-content" class="white-box">
          

<div class="flex-column" data-pagefind-body="">
  

  <nav class="content-nav">
    <ul class="flex-row">
      
        <li>
          <a href="/ticket/11009/">← Previous Ticket</a>
        
      
      
        </li><li>
          <a href="/ticket/11011/">Next Ticket →</a>
        </li>
      
    </ul>
  </nav>


<div class="ticket-info">
  <div class="flex-row flex-between-start">
    <h3>
      <a href="" class="ticket-number">#11010</a>
      <span class="ticket-status">closed</span>
      <span class="ticket-type">enhancement</span>
      <span class="ticket-resolution">(fixed)</span>
    </h3>

    <div class="ticket-dates">
      <p>Opened December 13, 2011 03:38PM UTC</p>
      
        <p>Closed June 18, 2012 03:30PM UTC</p>
      
      
        <p>Last modified June 18, 2012 03:58PM UTC</p>
      
    </div>
  </div>

  <h1 class="ticket-title">Make Deferred.then == Deferred.pipe like Promise/A</h1>

  <table class="ticket-properties">
    <tr>
      <th>Reported by:</th>
      <td>
        jaubourg
      </td>
      <th>Owned by:</th>
      <td></td>
    </tr>
    <tr>
      <th>
        Priority:
      </th>
      <td>
        low
      </td>
      
        <th class="missing">Milestone:</th>
      
      <td>
        <a href="/milestone/1.8">1.8</a>
      </td>
    </tr>
    <tr>
      <th>Component:</th>
      <td>deferred</td>
      
        <th>Version:</th>
      
      <td>1.7.1</td>
    </tr>
    <tr>
      
        <th>Keywords:</th>
      
      <td>1.8-discuss</td>
      
        <th class="missing">Cc:</th>
      
      <td></td>
    </tr>
    <tr>
      <th class="missing">
        Blocked by:
      </th>
      <td></td>
      <th class="missing">
        Blocking:
      </th>
      <td></td>
    </tr>
  </table>
  <div class="ticket-info-bottom">
    <h5 class="ticket-description-title">Description</h5>
    <div class="ticket-description"><p>It consists primarily in having promise.then implemented like promise.pipe.</p><p>We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).</p><p>Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</p></div>
  </div>
</div>

<details>
  <summary class="ticket-details-summary">Attachments (0)</summary>

  <ul class="ticket-attachments">
    
  </ul>
</details>

<details open="">
  <summary class="ticket-details-summary">Change History (19)</summary>
  
    <div class="ticket-change flex-column" id="comment:1">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 13, 2011 03:38PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:1">comment:1</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>component:</th>
                  <td>
                    
                      <span class="change-field-old">unfiled</span> → <span class="change-field-new">deferred</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>keywords:</th>
                  <td>
                    
                      <span class="change-field-new">→ 1.8-discuss</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>milestone:</th>
                  <td>
                    
                      <span class="change-field-old">None</span> → <span class="change-field-new">1.8</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>priority:</th>
                  <td>
                    
                      <span class="change-field-old">undecided</span> → <span class="change-field-new">low</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:2">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 13, 2011 03:40PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:2">comment:2</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies.&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:3">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 13, 2011 04:29PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:3">comment:3</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:4">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 14, 2011 03:34AM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:4">comment:4</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1, Yeah, we should.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:5">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 14, 2011 03:34AM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:5">comment:5</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">open</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:6">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 14, 2011 04:16PM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:6">comment:6</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>-1, The needed functionality is there.  I'd rather not make a breaking change right now.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:7">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 14, 2011 04:48PM UTC by <span class="author">rwaldron</span></span>
        <a class="ticket-change-link" href="#comment:7">comment:7</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1, I'm torn, I want great APIs, but I don't want breaking changes</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:8">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed December 15, 2011 07:28AM UTC by <span class="author">mikesherov</span></span>
        <a class="ticket-change-link" href="#comment:8">comment:8</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:9">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 01, 2012 11:31PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:9">comment:9</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span> → <span class="change-field-new">It consists primarily in having promise.then implemented like promise.pipe.&#92;
&#92;
We can keep current promise.then under a new alias (attach?) for people who would still want to add callbacks without the cost promise.pipe implies (though we have done, fail and progress for this already).&#92;
&#92;
Change is breaking but only to those who used the value returned by promise.then (either by storing the object or using chaining). I think the tradeof is reasonable enough.</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p><a href="https://github.com/jquery/jquery/tree/1.8/%2311010/Deferred" class="ext-link"><span class="icon"></span>https://github.com/jquery/jquery/tree/1.8/%2311010/Deferred</a></p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:10">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 25, 2012 11:53PM UTC by <span class="author">domenic@domenicdenicola.com</span></span>
        <a class="ticket-change-link" href="#comment:10">comment:10</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>+1, please. This is causing a lot of grief over at <a href="https://github.com/domenic/chai-as-promised/issues/1" class="ext-link"><span class="icon"></span>https://github.com/domenic/chai-as-promised/issues/1</a></p><p>One notable change besides fixing then to work more like pipe is trapping thrown exceptions to make them become rejections.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:11">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 12:54AM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:11">comment:11</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I don't see jQuery's Deferreds (mis-)handling exceptions the way Promise/A asks for anytime in the future. BTW, I don't see anything about exceptions anymore in the <a href="http://wiki.commonjs.org/wiki/Promises/A" class="ext-link"><span class="icon"></span>proposal</a> (but it's late and I don't see straight at that hour).</p><p>Anyway, here are my 2 cents on the issue.</p><p>First, a design based around hindering exceptions is a nightmare when it comes to debugging: there is nothing worse than a program doing nothing in case of an error, especially in an asynchronous environment. I'd rather have the error as vocal as possible to quickly pinpoint the problem: that, to me, is where exceptions shine.</p><p>Then, the specific design decision we're talking about is very restrictive from an API point of view unless you wanna get into some unwarantedly convoluted logic.</p><p>See, done, fail and progress would have to return a new Promise so that it is in a failed state if and when the given callback throws an exception. Not only does this incur a big performance hit (while, most of the time, you just want to add a callback, not filter/chain anything), but what happens if (like in the case of done, fail and progress) you can provide several callbacks? What is the rejection value if 2 or 3 of them throw an exception? The first exception? All 2 or 3 of them? Should the execution continue for this bunch if and when the first one throws an exception or should it stop right away?</p><p>Think it through, there is no good answer.</p><p>Not to mention the internal structure needed to keep track of everything (if you're interested in preventing memory build-ups or plain leaks, that is).</p><p>Now, let's also see what we're talking about from a coding point of view:</p><pre class="wiki">promise.then(function() {
   throw "woops"; 
});
</pre><p>Nothing is thrown. Never mind you say: let's add a callback for that specific case:</p><pre class="wiki">promise.then(function() {
   throw "woops"; 
}).then( null, function( whatIsThrown ) {
   throw "another hiccup";
});
</pre><p>And so on, and so on, and good luck finding what causes a problem in your code if and when an exception is thrown deep into the infinite nest of promises.</p><p>Now, there are two kinds of exceptions: those you don't expect, those you do expect. I see no value in silencing exceptions you don't expect as I made clear before, but what about programming by exception? I do hope that's not why Promises are supposed to silence exceptions and return a failed Promise.</p><p>I guess we're supposed to do things like this:</p><pre class="wiki">promise.then(function( data ) {
    if ( !data ) {
       throw "no data";
    }
    return parse( data );
}).then( null, function( error ) {
    console.log( error ); // will HOPEFULLY output "no data"
});
</pre><p>It's comfortable in the sense it looks like synchronous code, but what if parse throws an exception? Yes, you end up having to deal with all possible outcome in the following fail handler. This problem is exactly why Exceptions were invented in the first place: to bypass the usual code flow in case of unexpected failures while providing a mechanism to handle those you do expect and nothing more.</p><p>In jQuery 1.8 (and right now if you use pipe instead of then), you can do the following:</p><pre class="wiki">promise.then(function( data ) {
    return data
        ? parse( data )
        : $.Deferred().reject( "no data" );
}).then(function( error ) {
    console.log( error ); // will ALWAYS output "no data"
});
</pre><p>You make it explicit you want the following Promise to be rejected and you don't mix applicative and runtime errors.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:12">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 01:26AM UTC by <span class="author">domenic@domenicdenicola.com</span></span>
        <a class="ticket-change-link" href="#comment:12">comment:12</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>The spec line you missed is</p><blockquote> If the callback throws an error, the returned promise will be moved to failed state.</blockquote><p></p><hr><p></p><p>This is really unfortunate to hear. The entire parallel is that sync exceptions &lt;--&gt; async rejections, which is broken and apparently actively rejected by this decision.</p><p>I disagree that the point of exceptions is to be vocal and fail as soon as possible; the point is actually to allow you to ignore them until some part of your code is able to handle them. That is why the bubbling behavior is so important, in contrast to e.g. Node.js <code>callback(err, result)</code> solutions.</p><p>If there are insurmountable performance concerns about returning a new promise, though, then <a href="/wiki/CommonJS">CommonJS</a>/A compatability is indeed truly broken:</p><blockquote> This function should return a new promise</blockquote><p>As for the issue of unobserved exceptions never being seen---how is this different from unobserved rejections never being seen?</p><p>Finally, your last example doesn't make much sense to me (even assuming you meant to put a <code>null</code> as the first param): <code>parse</code> could return a rejected promise, and then you're back to "HOPEFULLY".</p><p></p><hr><p></p><p>With this in mind, given the numerous Promises/A violations [1] that will cripple interoperability, may I plead with you to remove/deprecate <code>then</code> from the jQuery promise interface? The vast majority of code samples seem to prefer <code>done</code> anyway, so not too much code would be broken.</p><p>[1] If you disagree that they are not numerous, I can give you some test suites that fail extensively when I swap Q or when.js for jQuery promises, even after doing a s/<code>.then</code>/<code>.pipe</code>/g.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:13">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 01:39AM UTC by <span class="author">domenic@domenicdenicola.com</span></span>
        <a class="ticket-change-link" href="#comment:13">comment:13</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Oh, and another interoperability thing I forgot---this decision makes it impossible to chain jQuery promises in an interoperable way, because you need to take a dependency on jQuery in order to get access to <code>$.Deferred().reject</code>. You cannot write generic promise-based functions like the following:</p><pre class="wiki">
function ensureHasUsername(promiseForUser) {
  return promiseForUser.then(function (user) {
    if (!user.username) {
      throw new Error("No username!");
    }
  });
}

function doOperationAndDontGiveUp(operation) {
  return operation().then(
    null,
    function (error) {
      if (error instanceof TemporaryNetworkError) {
        console.log("Retrying after error", error);
        return operation();
      }
      throw error;
    }
  });
}
</pre><p>These are just simple examples, but in general it is impossible to use jQuery promises with a "promise aware" library that contains functions that both accept and return promises, in an agnostic way. (Chai as Promised, of course, being my particular case.)</p><p>The Promises/A spec is so minimal, but every detail of it has been carefully thought out, with a maximum concern toward building an ecosystem of interoperable promises based solely on the <code>then</code> method. When <code>typeof putativePromise.then === "function"</code> succeeds, but aspects of the spec are not followed, headaches ensue. Again I would advocate for making it explicit that you are opting out of this ecosystem, by removing <code>then</code>.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:14">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 02:56AM UTC by <span class="author">rwaldron</span></span>
        <a class="ticket-change-link" href="#comment:14">comment:14</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <blockquote> With this in mind, given the numerous Promises/A violations [1] that will cripple interoperability, may I plead with you to remove/deprecate <code>then</code> from the jQuery promise interface? The vast majority of code samples seem to prefer <code>done</code> anyway, so not too much code would be broken. </blockquote><p>This is  grossly negligent request. Considering everything else you wrote was very thoughtful, to finish your feedback by asking jQuery to remove part of its API because two "mostly academic" pieces of code aren't interoperable, makes your point go from very helpful to laughably insane.</p><p>Really - how often are people writing large scale applications that use Q, when.js _and_ jQuery AND need to pass promises back and forth between the three? I'd say probably none.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:15">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 04:53AM UTC by <span class="author">domenic@domenicdenicola.com</span></span>
        <a class="ticket-change-link" href="#comment:15">comment:15</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I'm sorry it came across that way. It certainly didn't seem grossly laughable at the time. Is it more laughable than Promises/A compliance? I honestly thought they would both be backward-incompatible changes and thus on the same level.</p><p>And I don't think "mostly academic" is a quote from me, at least?</p><p>To answer your use case, the problem isn't people writing applications that use multiple types of promises. We use Q because of jQuery 1.7's shortcomings, and know we need to assimilate any Ajax promises before using so that they have Promises/A behavior. That's fine.</p><p>The problem, as I tried to make clear, is library authors, and being part of a larger ecosystem. Currently, no library authors can "trust" jQuery promises. Whether they be Chai as Promised, capsela, wire.js, or taskjs.org, jQuery promises cannot be trusted: they violate the Promises/A contract while faking adherence to it.</p><p>As long as such promises are in the ecosystem, libraries must compensate for them. The only way to do this, really, is to mistrust any incoming promise and assimilate it as a <code>$library_authors_favorite_promise_implementation</code> promise. Then the promises coming out of your library functions will be of a different type from those coming into it, leaving lots of people out in the dark.</p><p>For example, in Chai as Promised I would wrap all promises passed in with <code>Q.when</code>. But then, users of my library would receive back Q promises, when they passed in jQuery promises, so e.g. they'd have to switch to <code>fin</code> instead of <code>always</code>; the <code>done</code> method would go away; etc. Even worse, well-behaved promises such as those of when.js would be caught in this net of mistrust. Likely only Q users end up using Chai as Promised.</p><p>The result is a fragmented ecosystem: Chai as Promised and Capsela treat Q as first-class; wire.js treats when.js as first-class; taskjs.org treats its own custom implementation as first class... And nobody treats jQuery as first class, because it continues to miss the boat on the growing promise ecosystem due to decisions like this one.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:16">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 08:58AM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:16">comment:16</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
                <tr>
                  <th>_comment0:</th>
                  <td>
                    
                      <span class="change-field-old">(rushed answer, since I&#39;m very busy right now and need to get back to stuff that pay the rent, try and understand what is said rather than cherry-pick parts to troll about, thank you)&#92;
&#92;
Replying to [comment:12 domenic@…]:&#92;
&gt; The spec line you missed is&#92;
&gt; &#92;
&gt; &gt; If the callback throws an error, the returned promise will be moved to failed state.&#92;
&gt; &#92;
&gt; ----&#92;
&#92;
Thanks for pointing this out, it was close to 3am where I was and I couldn&#39;t find it.&#92;
&#92;
&gt; &#92;
&gt; This is really unfortunate to hear. The entire parallel is that sync exceptions &lt;--&gt; async rejections, which is broken and apparently actively rejected by this decision.&#92;
&gt; &#92;
&gt; I disagree that the point of exceptions is to be vocal and fail as soon as possible; the point is actually to allow you to ignore them until some part of your code is able to handle them. That is why the bubbling behavior is so important, in contrast to e.g. Node.js `callback(err, result)` solutions.&#92;
&gt; &#92;
&#92;
That&#39;s complete non-sense. Exception do not &quot;allow you to ignore them&quot;, they plain and simply go over you head UNLESS you catch them. If what you state was through then every javascript statement should be embedded in an if statement:&#92;
&#92;
{{{#!js&#92;
if( typeof TheException !== &quot;thetypeIdontwant&quot; ) { doSomething(); }&#92;
}}}&#92;
&#92;
while thanks to Exception not being caught and put in variables all the time, you code actually is:&#92;
&#92;
{{{#!js&#92;
doSomething();&#92;
}}}&#92;
&#92;
Which, by the way, is exactly what the Promise/A spec expects you to do in your fail callback.&#92;
&#92;
&gt; If there are insurmountable performance concerns about returning a new promise, though, then CommonJS/A compatability is indeed truly broken:&#92;
&gt; &#92;
&gt; &gt; This function should return a new promise&#92;
&gt; &#92;
&#92;
There is an ENORMOUS performance hit since you need to create a Promise beforehand while waiting for the returned value of whatever handler will fire first, then, if the handler wants to chain with another async operation, another Promise is created which states are piped into the internal one created when &quot;then&quot; was first call.&#92;
&#92;
This is as inefficient as it can get.&#92;
&#92;
Do you realize that, at least half of the time, all you want to do is attach a handler with no interest in filtering/chaining? This is why we first implemented then like we did and waited for 1.6 (see if Deferreds got traction) before introducing pipe.&#92;
&#92;
In 1.8, we will remove the old then and replace it with current pipe. But the very sadening consequence is that we&#39;ll have to tell people to use the non-standard done, fail and progress, because the proposal doesn&#39;t provide simple, EFFICIENT, mean to just add a callback.&#92;
&#92;
&gt; As for the issue of unobserved exceptions never being seen---how is this different from unobserved rejections never being seen?&#92;
&gt; &#92;
&#92;
The DEVELOPPER performs rejections, the DEVELOPPER AND THE ENVIRONMENT throw exceptions. What is so hard to understand? It&#39;s not about the exception YOU throw but about the unexpected exceptions... you know, the ones that will happen whenever your lib is used in the wild.&#92;
&#92;
It&#39;s fascinating the way you&#39;re just dodging the difference between expected and unexpected exceptions and the clutter it adds in the code if you have to handle them all with if statements.&#92;
&#92;
If you silence runtime non-applicative-relevant exceptions (IE. BUGS), then nobody will use your lib.&#92;
&#92;
&gt; Finally, your last example doesn&#39;t make much sense to me (even assuming you meant to put a `null` as the first param): `parse` could return a rejected promise, and then you&#39;re back to &quot;HOPEFULLY&quot;.&#92;
&gt; &#92;
&gt; ---&#92;
&#92;
Of course, but it&#39;s not an issue since it&#39;s an EXPECTED outcome of parse while, in the code sample, I made it quite obvious, and ON PURPOSE, that I don&#39;t expect parse to throw an exception unless there is a BUG.&#92;
&#92;
Take it this way: you expect the input to be either empty (no data) or well-formed. There is no need for code handling other situations because an ill-formed data is a BUG and you want BUGS to show up.&#92;
&#92;
You keep on assuming ALL exception thrown are relevant to the application logic. 20 years after having been introduced to them, I can tell very few of them are, unless you start throwing them all around as if they were flags, just like Promise/A implicitely advocates.&#92;
&#92;
&gt;&#92;
&gt; With this in mind, given the numerous Promises/A violations [1] that will cripple interoperability, may I plead with you to remove/deprecate `then` from the jQuery promise interface? The vast majority of code samples seem to prefer `done` anyway, so not too much code would be broken.&#92;
&gt;&#92;
&gt; [1] If you disagree that they are not numerous, I can give you some test suites that fail extensively when I swap Q or when.js for jQuery promises, even after doing a s/`.then`/`.pipe`/g.&#92;
&#92;
Most of them are related to jQuery expecting Observables to have a promise method. Don&#39;t kid yourself.&#92;
&#92;
Replying to [comment:13 domenic@…]:&#92;
&gt; Oh, and another interoperability thing I forgot---this decision makes it impossible to chain jQuery promises in an interoperable way, because you need to take a dependency on jQuery in order to get access to `$.Deferred().reject`. You cannot write generic promise-based functions like the following:&#92;
&gt; &#92;
&gt; &#92;
&gt; {{{&#92;
&gt; function ensureHasUsername(promiseForUser) {&#92;
&gt;   return promiseForUser.then(function (user) {&#92;
&gt;     if (!user.username) {&#92;
&gt;       throw new Error(&quot;No username!&quot;);&#92;
&gt;     }&#92;
&gt;   });&#92;
&gt; }&#92;
&gt; &#92;
&gt; function doOperationAndDontGiveUp(operation) {&#92;
&gt;   return operation().then(&#92;
&gt;     null,&#92;
&gt;     function (error) {&#92;
&gt;       if (error instanceof TemporaryNetworkError) {&#92;
&gt;         console.log(&quot;Retrying after error&quot;, error);&#92;
&gt;         return operation();&#92;
&gt;       }&#92;
&gt;       throw error;&#92;
&gt;     }&#92;
&gt;   });&#92;
&gt; }&#92;
&gt; }}}&#92;
&gt; &#92;
&gt; These are just simple examples, but in general it is impossible to use jQuery promises with a &quot;promise aware&quot; library that contains functions that both accept and return promises, in an agnostic way. (Chai as Promised, of course, being my particular case.)&#92;
&gt;&#92;
&#92;
That&#39;s complete bullshit. You WILL have a Deferred implementation as a dependency in your code. So, you can write something like this:&#92;
&#92;
{{{&#92;
function ensureHasUsername( promiseForUser ) {&#92;
  return promiseForUser.then(function ( user ) {&#92;
    if ( !user.username ) {&#92;
      return yourDeferredImplementation()&#92;
        [ &quot;yourRejectMethodName&quot; ]( new Error(&quot;No username!&quot;) )&#92;
        [ &quot;yourPromiseGetter&quot; ]();&#92;
    }&#92;
  });&#92;
}&#92;
&#92;
function doOperationAndDontGiveUp( operation ) {&#92;
  return operation().then(&#92;
    null,&#92;
    function ( error ) {&#92;
      if ( error instanceof TemporaryNetworkError ) {&#92;
        console.log( &quot;Retrying after error&quot;, error );&#92;
        return operation();&#92;
      }&#92;
      return error;&#92;
    }&#92;
  });&#92;
}&#92;
}}}&#92;
&#92;
It should be perfectly interoperable. Of course, it means you have to catch exceptions you EXPECT rather than play it lazy. If you silence exceptions, you doom everyone that will use your lib and have a bug somewhere in their app they need to track down.&#92;
&#92;
When you have a one hour window to find a bug before putting a site in production (you know, when everything works locally but something fails when put in the production environment), I can guarantee you that you don&#39;t want any library to hinder exceptions.&#92;
&#92;
Now, when it comes to the example above, it actually doesn&#39;t work with jQuery because jQuery expects a promise() method on Observables. I&#39;m open to discussion regarding testing for &quot;then&quot; in addition, so that this kind of code is truly interoperable.&#92;
&#92;
&gt; The Promises/A spec is so minimal, but every detail of it has been carefully thought out, with a maximum concern toward building an ecosystem of interoperable promises based solely on the `then` method. When `typeof putativePromise.then === &quot;function&quot;` succeeds, but aspects of the spec are not followed, headaches ensue. Again I would advocate for making it explicit that you are opting out of this ecosystem, by removing `then`.&#92;
&#92;
I don&#39;t think Promise/A has been as carefully thought out as you try to make it sound:&#92;
* no performant means to attach callbacks,&#92;
* when is not part of the standard (which causes REAL interoperability issues),&#92;
* silencing exceptions IS a gigantic mistake,&#92;
* no standard way to mark a non-promise object as Observable through a promise (most libs will have a promise field on such objects, but the approach is weak, especially if the promise has to be dynamically generated, as is the case with [http://api.jquery.com/promise/ fn.promise]),&#92;
* no minimal standard regarding the object that sets the state of a Promise (Deferred), not even naming hints (and now people are attacking us for not using the terms they like btw).&#92;
&#92;
A lot of the grief against jQuery is actually due to shortcomings in the Promise/A spec. I like Kris Zyp very much (we chatted a lot when I was coding $.Deferred) but I think the spec is half-baked. Lots of people are jumping onto the boat before it sailed. I&#39;m afraid it will sink fast because of a lack of reality check (silencing exceptions being the biggest point).</span> → <span class="change-field-new">1335431254864096</span>
                    
                  </td>
                </tr>
              
            
              
            
          </tbody>
        </table>
        
          
        
          
            <div class="ticket-comment-body">
              <p>(rushed answer, since I'm very busy right now and need to get back to stuff that pay the rent, try and understand what is said rather than cherry-pick parts to troll about, thank you)</p><p>Replying to [comment:12 domenic@…]:</p><blockquote> The spec line you missed is  &gt; If the callback throws an error, the returned promise will be moved to failed state.  ----</blockquote><p>Thanks for pointing this out, it was close to 3am where I was and I couldn't find it.</p><blockquote>  This is really unfortunate to hear. The entire parallel is that sync exceptions &lt;--&gt; async rejections, which is broken and apparently actively rejected by this decision.  I disagree that the point of exceptions is to be vocal and fail as soon as possible; the point is actually to allow you to ignore them until some part of your code is able to handle them. That is why the bubbling behavior is so important, in contrast to e.g. Node.js <code>callback(err, result)</code> solutions. </blockquote><p>That's complete non-sense. Exception do not "allow you to ignore them", they plain and simply go over you head UNLESS you catch them. If what you state was through then every javascript statement should be embedded in an if statement:</p><pre class="wiki">if( typeof TheException !== "thetypeIdontwant" ) { doSomething(); }
</pre><p>Which, by the way, is exactly what the Promise/A spec expects you to do in your fail callback.</p><p>While thanks to Exception not being caught and put in variables all the time, you code actually is:</p><pre class="wiki">doSomething();
</pre><blockquote> If there are insurmountable performance concerns about returning a new promise, though, then <a href="/wiki/CommonJS">CommonJS</a>/A compatability is indeed truly broken:  &gt; This function should return a new promise </blockquote><p>There is an ENORMOUS performance hit since you need to create a Promise beforehand while waiting for the returned value of whatever handler will fire first, then, if the handler wants to chain with another async operation, another Promise is created which states are piped into the internal one created when "then" was first call.</p><p>This is as inefficient as it can get.</p><p>Do you realize that, at least half of the time, all you want to do is attach a handler with no interest in filtering/chaining? This is why we first implemented then like we did and waited for 1.6 (see if Deferreds got traction) before introducing pipe.</p><p>In 1.8, we will remove the old then and replace it with current pipe. But the very sadening consequence is that we'll have to tell people to use the non-standard done, fail and progress, because the proposal doesn't provide simple, EFFICIENT, mean to just add a callback.</p><blockquote> As for the issue of unobserved exceptions never being seen---how is this different from unobserved rejections never being seen? </blockquote><p>The DEVELOPPER performs rejections, the DEVELOPPER AND THE ENVIRONMENT throw exceptions. What is so hard to understand? It's not about the exception YOU throw but about the unexpected exceptions... you know, the ones that will happen whenever your lib is used in the wild.</p><p>It's fascinating the way you're just dodging the difference between expected and unexpected exceptions and the clutter it adds in the code if you have to handle them all with if statements.</p><p>If you silence runtime non-applicative-relevant exceptions (IE. BUGS), then nobody will use your lib.</p><blockquote> Finally, your last example doesn't make much sense to me (even assuming you meant to put a <code>null</code> as the first param): <code>parse</code> could return a rejected promise, and then you're back to "HOPEFULLY".  ---</blockquote><p>Of course, but it's not an issue since it's an EXPECTED outcome of parse while, in the code sample, I made it quite obvious, and ON PURPOSE, that I don't expect parse to throw an exception unless there is a BUG.</p><p>Take it this way: you expect the input to be either empty (no data) or well-formed. There is no need for code handling other situations because an ill-formed data is a BUG and you want BUGS to show up.</p><p>You keep on assuming ALL exception thrown are relevant to the application logic. 20 years after having been introduced to them, I can tell very few of them are, unless you start throwing them all around as if they were flags, just like Promise/A implicitely advocates.</p><p>&gt;</p><blockquote> With this in mind, given the numerous Promises/A violations [1] that will cripple interoperability, may I plead with you to remove/deprecate <code>then</code> from the jQuery promise interface? The vast majority of code samples seem to prefer <code>done</code> anyway, so not too much code would be broken.</blockquote><p>&gt;</p><blockquote> [1] If you disagree that they are not numerous, I can give you some test suites that fail extensively when I swap Q or when.js for jQuery promises, even after doing a s/<code>.then</code>/<code>.pipe</code>/g.</blockquote><p>Most of them are related to jQuery expecting Observables to have a promise method. Don't kid yourself.</p><p>Replying to [comment:13 domenic@…]:</p><blockquote> Oh, and another interoperability thing I forgot---this decision makes it impossible to chain jQuery promises in an interoperable way, because you need to take a dependency on jQuery in order to get access to <code>$.Deferred().reject</code>. You cannot write generic promise-based functions like the following:   <pre class="wiki">
&gt; function ensureHasUsername(promiseForUser) {
&gt;   return promiseForUser.then(function (user) {
&gt;     if (!user.username) {
&gt;       throw new Error("No username!");
&gt;     }
&gt;   });
&gt; }
&gt; 
&gt; function doOperationAndDontGiveUp(operation) {
&gt;   return operation().then(
&gt;     null,
&gt;     function (error) {
&gt;       if (error instanceof TemporaryNetworkError) {
&gt;         console.log("Retrying after error", error);
&gt;         return operation();
&gt;       }
&gt;       throw error;
&gt;     }
&gt;   });
&gt; }
&gt; </pre>  These are just simple examples, but in general it is impossible to use jQuery promises with a "promise aware" library that contains functions that both accept and return promises, in an agnostic way. (Chai as Promised, of course, being my particular case.)</blockquote><p>&gt;</p><p>That's complete bullshit. You WILL have a Deferred implementation as a dependency in your code. So, you can write something like this:</p><pre class="wiki">
function ensureHasUsername( promiseForUser ) {
  return promiseForUser.then(function ( user ) {
    if ( !user.username ) {
      return yourDeferredImplementation()
        [ "yourRejectMethodName" ]( new Error("No username!") )
        [ "yourPromiseGetter" ]();
    }
  });
}

function doOperationAndDontGiveUp( operation ) {
  return operation().then(
    null,
    function ( error ) {
      if ( error instanceof TemporaryNetworkError ) {
        console.log( "Retrying after error", error );
        return operation();
      }
      return error;
    }
  });
}
</pre><p>It should be perfectly interoperable. Of course, it means you have to catch exceptions you EXPECT rather than play it lazy. If you silence exceptions, you doom everyone that will use your lib and have a bug somewhere in their app they need to track down.</p><p>When you have a one hour window to find a bug before putting a site in production (you know, when everything works locally but something fails when put in the production environment), I can guarantee you that you don't want any library to hinder exceptions.</p><p>Now, when it comes to the example above, it actually doesn't work with jQuery because jQuery expects a promise() method on Observables. I'm open to discussion regarding testing for "then" in addition, so that this kind of code is truly interoperable.</p><blockquote> The Promises/A spec is so minimal, but every detail of it has been carefully thought out, with a maximum concern toward building an ecosystem of interoperable promises based solely on the <code>then</code> method. When <code>typeof putativePromise.then === "function"</code> succeeds, but aspects of the spec are not followed, headaches ensue. Again I would advocate for making it explicit that you are opting out of this ecosystem, by removing <code>then</code>.</blockquote><p>I don't think Promise/A has been as carefully thought out as you try to make it sound:</p><ul><li>no performant means to attach callbacks,</li><li>when is not part of the standard (which causes REAL interoperability issues),</li><li>silencing exceptions IS a gigantic mistake,</li><li>no standard way to mark a non-promise object as Observable through a promise (most libs will have a promise field on such objects, but the approach is weak, especially if the promise has to be dynamically generated, as is the case with <a href="http://api.jquery.com/promise/" class="ext-link"><span class="icon"></span>fn.promise</a>),</li><li>no minimal standard regarding the object that sets the state of a Promise (Deferred), not even naming hints (and now people are attacking us for not using the terms they like btw).</li></ul><p>A lot of the grief against jQuery is actually due to shortcomings in the Promise/A spec. I like Kris Zyp very much (we chatted a lot when I was coding $.Deferred) but I think the spec is half-baked. Lots of people are jumping onto the boat before it sailed. I'm afraid it will sink fast because of a lack of reality check (silencing exceptions being the biggest point).</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:17">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed April 26, 2012 05:34PM UTC by <span class="author">domenic@domenicdenicola.com</span></span>
        <a class="ticket-change-link" href="#comment:17">comment:17</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
                <tr>
                  <th>_comment0:</th>
                  <td>
                    
                      <span class="change-field-old">Replying to [comment:16 jaubourg]:&#92;
&#92;
OK, wow, it looks like this discussion has taken a turn for the acrimonious. I&#39;m sorry for my part in that, and appreciate the time you&#39;ve put in replying to me so far. I ensure you my intention was never to troll, to distract you from paying the rent, or to be grossly negligent.&#92;
&#92;
It&#39;s clear you&#39;ve made up your mind on these points, and I do understand your position and reasons for it—I simply disagree with them, and thus argued against them. On reflection, &quot;yes, but&quot; breeds a better discussion than &quot;but&quot; alone, so apologies for taking that latter tack.&#92;
&#92;
Since I do understand your reasons, and recognize I&#39;m not going to change your mind, I&#39;d like to just take some time to help you understand my position. If we can agree to disagree, I&#39;ll leave it at that.&#92;
&#92;
I would appreciate a reasoned response that takes the time to read and think about my points, so if that means waiting days for a reply until you have more time to respond without feeling rushed, please do so. I recognize that, while promises are a passion of mine (Q is the most-watched library I collaborate with on GitHub), they are only a tiny portion of jQuery, so I do not expect you to match my response time.&#92;
&#92;
----&#92;
&#92;
&gt; That&#39;s complete non-sense. Exception do not &quot;allow you to ignore them&quot;, they plain and simply go over you head UNLESS you catch them.&#92;
&#92;
I think we are talking past each other. It&#39;s exactly that &quot;going over your head&quot; behavior that I want in a promise setting. The problem comes, I think, that you do not accept the Promises/A equivalence between rejection handlers and `catch` blocks. As for the issue of exception type-checking, I can assure you that this is not how Promise/A-using code works: like `catch` blocks, rejection handlers are inserted only at seams between systems, where usually any error at all is cause for alarm and handling.&#92;
&#92;
&gt; There is an ENORMOUS performance hit&#92;
&#92;
I admit the jQuery team is much more knowledgable about the vagaries of JavaScript performance. You presumably have a much broader view of what&#39;s important and what&#39;s not, and in what setting (mobile etc.). That said, we are using Q promises in a 170K LOC HTML5 desktop application, as well as in a (much smaller) Node.js server, and they have never been even close to a performance bottleneck. This seems especially true in the case of jQuery, where promises are used to react to Ajax, animations, etc. which will obviously dwarf the overhead of creating a JavaScript object and piping states around. But I admit, you guys have a much better grasp on the performance implications, e.g. maybe creating objects is more expensive on mobile WebKit.&#92;
&#92;
&gt; In 1.8, we will remove the old then and replace it with current pipe. But the very sadening consequence is that we&#39;ll have to tell people to use the non-standard done, fail and progress, because the proposal doesn&#39;t provide simple, EFFICIENT, mean to just add a callback. &#92;
&#92;
It is great to hear that you&#39;ll continue the trend of encouraging non-`then` usage; this will help clarify the division. Dare I ask you, jaubourg, about how you feel w.r.t. depracating `then`? (I&#39;d like to not get laughed at again though, so if you think it&#39;s absurd just ignore that query.)&#92;
&#92;
As for efficient means to just add a callback, I thought that was what `$.Callbacks` was for? I guess there might be some historical issues here that are too late to address.&#92;
&#92;
&gt; The DEVELOPPER performs rejections, the DEVELOPPER AND THE ENVIRONMENT throw exceptions. What is so hard to understand? It&#39;s not about the exception YOU throw but about the unexpected exceptions... you know, the ones that will happen whenever your lib is used in the wild.&#92;
&#92;
&gt; It&#39;s fascinating the way you&#39;re just dodging the difference between expected and unexpected exceptions and the clutter it adds in the code if you have to handle them all with if statements.&#92;
&#92;
&gt; If you silence runtime non-applicative-relevant exceptions (IE. BUGS), then nobody will use your lib. &#92;
&#92;
Again, the intent of Promises/A is that there is no difference: rejections should be no more or less powerful than exceptions, but instead should simply replace exceptions in the async context. There are unexpected rejections, just as there are unexpected exceptions, and nobody clutters their asynchronous code with `if` statements in their rejection handlers any more than people clutter their synchronous code with `if` statements in their `catch` blocks.&#92;
&#92;
I think the line between developer and environment is much more blurry than you are trying to make it. When I use a third-party asynchronous library that returns rejected promises, is that the developer or the environment? What about a third-party synchronous library that throws exceptions? If that third-party library returns a rejected promise, but I forget to observe rejection, this will cause the same problems that &quot;forgetting&quot; to wrap third-party library code in `try`/`catch` does. Yes, there is a difference, I admit: if your fulfillment handler does a `undefined.foo = &quot;bar&quot;`, that&#39;s clearly an environment-thrown exception. But you&#39;d need another `try`/`catch` to handle that in a synchronous workflow (wherein it would be your `catch` block being boneheaded), so why the resistance to adding another rejection handler in an asynchronous one?&#92;
&#92;
As for the silencing issue, I think you are referring to the problem wherein unobserved rejections that bubble all the way to the top need some way of making their presence known, just like unobserved exceptions do. This is solved in various ways by various promise libraries: in Q we have provided the `end` capping method [1] and, in master, a live console-list of unobserved rejections. In WinJS promises (Windows 8&#39;s built-in promise framework for writing desktop apps) you can use an explicitly non-chaining `done` method, or a `WinJS.promise.onerror` handler. (Microsoft actually has a great article about this problem [3]—really highly recommended reading, although I know you are busy). From my understanding you find the tradeoff to be too great of a price to pay for the potential of lost exceptions, and that&#39;s fine. But it&#39;s a tradeoff that those using Promises/A promises have chosen to buy into.&#92;
&#92;
[1]: http://documentup.com/kriskowal/q/#tutorial/the-end&#92;
[2]: http://msdn.microsoft.com/en-us/library/windows/apps/hh701079.aspx&#92;
[3]: http://msdn.microsoft.com/en-us/library/windows/apps/hh700337.aspx&#92;
&#92;
&gt; That&#39;s complete bullshit. You WILL have a Deferred implementation as a dependency in your code.&#92;
&#92;
I really, strongly, disagree in the case of library authors. I think if you re-read what I was trying to say, this will become more clear. Deferreds are only necessary for adapting callback-style code. Once you have promises in your system, everything can be done with chaining in a library-agnostic way, which is why Promises/A is so powerful. I gave several examples of potential utility functions that promise-based libraries could provide. And of course I&#39;ll haul out Chai as Promised once again: it allows you to make assertions about the state of promises that then become promises, e.g.&#92;
&#92;
{{{&#92;
expect(promise).to.be.rejected.with(TypeError).then(&#92;
    function () {&#92;
        // promise was rejected with TypeError&#92;
    },&#92;
    function (err) {&#92;
        // err contains an AssertionError saying &quot;expected TypeError but was WhateverError&quot;&#92;
    }&#92;
);&#92;
assert.eventually.deepEqual(promise, { foo: { bar: &quot;baz&quot; } }).then(&#92;
    function () {&#92;
        // promise was fulfilled with something that was deepEqual to { foo: { bar: &quot;baz&quot; } }&#92;
    },&#92;
    function (err) {&#92;
        // err contains AssertionError.&#92;
    }&#92;
);&#92;
}}}&#92;
&#92;
This is accomplished with zero dependency on a deferred library, and simply uses the `.then` function of whatever it is given. It has an extensive test suite that passes with Q promises, When.js promises, and WinJS promises, but fails with jQuery promises even after s/`.then`/`.pipe`/g (and, from a glance, none of the failures are related to expected a `.promise` method).&#92;
&#92;
&gt; It should be perfectly interoperable.&#92;
&#92;
Your first rewritten example takes on a deferred dependency, so the returned promise will not be of the type passed in: now nobody wants to use my library, because they have to learn how to use Q promises when they were using WinJS promises all along. Your second example will not work with any Promises/A compliant promises, since it returns the error instead of throwing it, thus causing the promise to be fulfilled (*now* we&#39;re swallowing exceptions :P). This is part of why I say that Promises/A has really thought this out: it&#39;s not easy to get such things right.&#92;
&#92;
&gt; I don&#39;t think Promise/A has been as carefully thought out as you try to make it sound: &#92;
&#92;
Promises/A is the minimal spec. Some of what you are referring to is addressed by Promises/B [4] or UncommonJS promises [5]. Of course, neither of these specs have gotten much traction, because just getting people to agree to the basics of Promises/A is (1) hard enough; (2) powerful enough to enable interoperability.&#92;
&#92;
[4]: http://wiki.commonjs.org/wiki/Promises/B&#92;
[5]: http://kriskowal.github.com/uncommonjs/promises/specification&#92;
&#92;
Yes, Promises/A not perfect—especially if your priorities are not a direct synchronous-to-asynchronous correspondence—but I hope you can see why it has its proponents. If jQuery wants to go off in a different direction, that&#39;s fine, and I understand, but I just want to make sure I&#39;ve helped you see the tradeoffs being made. It sounds like you are aware of most of them, and that jQuery intends to, in effect, cut itself off from the Promises/A ecosystem and encourage its own ecosystem, in which performance and never accidentally silencing exceptions are a higher priority than composability and interoperability.&#92;
&#92;
----&#92;
&#92;
Thank you for your time, and sorry for making you read such a long treatise. As I said, promises are a passion of mine; I evangelize them heavily in the New York JavaScript community, and hate having to tell people to avoid jQuery promises when I do so. I hope I haven&#39;t exhausted your patience, and do appreciate that you&#39;re willing to engage with the Promises/A community like this.&#92;
</span> → <span class="change-field-new">1335461717847998</span>
                    
                  </td>
                </tr>
              
            
              
            
          </tbody>
        </table>
        
          
        
          
            <div class="ticket-comment-body">
              <p>Replying to [comment:16 jaubourg]:</p><p>OK, wow, it looks like this discussion has taken a turn for the acrimonious. I'm sorry for my part in that, and appreciate the time you've put in replying to me so far. I ensure you my intention was never to troll, to distract you from paying the rent, or to be grossly negligent.</p><p>It's clear you've made up your mind on these points, and I do understand your position and reasons for it—I simply disagree with them, and thus argued against them. On reflection, "yes, but" breeds a better discussion than "but" alone, so apologies for taking that latter tack.</p><p>Since I do understand your reasons, and recognize I'm not going to change your mind, I'd like to just take some time to help you understand my position. If we can agree to disagree, I'll leave it at that.</p><p>I would appreciate a reasoned response that takes the time to read and think about my points, so if that means waiting days for a reply until you have more time to respond without feeling rushed, please do so. I recognize that, while promises are a passion of mine (Q is the most-watched open source library I am a contributor on), they are only a tiny portion of jQuery, so I do not expect you to match my response time.</p><p></p><hr><p></p><blockquote> That's complete non-sense. Exception do not "allow you to ignore them", they plain and simply go over you head UNLESS you catch them.</blockquote><p>I think we are talking past each other. It's exactly that "going over your head" behavior that I want in a promise setting. The problem comes, I think, that you do not accept the Promises/A equivalence between rejection handlers and <code>catch</code> blocks. As for the issue of exception type-checking, I can assure you that this is not how Promise/A-using code works: like <code>catch</code> blocks, rejection handlers are inserted only at seams between systems, where usually any error at all is cause for alarm and handling.</p><blockquote> There is an ENORMOUS performance hit</blockquote><p>I admit the jQuery team is much more knowledgable about the vagaries of <a href="/wiki/JavaScript">JavaScript</a> performance. You presumably have a much broader view of what's important and what's not, and in what setting (mobile etc.). That said, we are using Q promises in a 170K LOC HTML5 desktop application, as well as in a (much smaller) Node.js server, and they have never been even close to a performance bottleneck. This seems especially true in the case of jQuery, where promises are used to react to Ajax, animations, etc. which will obviously dwarf the overhead of creating a <a href="/wiki/JavaScript">JavaScript</a> object and piping states around. But I admit, you guys have a much better grasp on the performance implications, e.g. maybe creating objects is more expensive on mobile <a href="/wiki/WebKit">WebKit</a>.</p><blockquote> In 1.8, we will remove the old then and replace it with current pipe. But the very sadening consequence is that we'll have to tell people to use the non-standard done, fail and progress, because the proposal doesn't provide simple, EFFICIENT, mean to just add a callback. </blockquote><p>It is great to hear that you'll continue the trend of encouraging non-<code>then</code> usage; this will help clarify the division. Dare I ask you, jaubourg, about how you feel w.r.t. depracating <code>then</code>? (I'd like to not get laughed at again though, so if you think it's absurd just ignore that query.)</p><p>As for efficient means to just add a callback, I thought that was what <code>$.Callbacks</code> was for? I guess there might be some historical issues here that are too late to address.</p><blockquote> The DEVELOPPER performs rejections, the DEVELOPPER AND THE ENVIRONMENT throw exceptions. What is so hard to understand? It's not about the exception YOU throw but about the unexpected exceptions... you know, the ones that will happen whenever your lib is used in the wild.</blockquote><blockquote> It's fascinating the way you're just dodging the difference between expected and unexpected exceptions and the clutter it adds in the code if you have to handle them all with if statements.</blockquote><blockquote> If you silence runtime non-applicative-relevant exceptions (IE. BUGS), then nobody will use your lib. </blockquote><p>Again, the intent of Promises/A is that there is no difference: rejections should be no more or less powerful than exceptions, but instead should simply replace exceptions in the async context. There are unexpected rejections, just as there are unexpected exceptions, and nobody clutters their asynchronous code with <code>if</code> statements in their rejection handlers any more than people clutter their synchronous code with <code>if</code> statements in their <code>catch</code> blocks.</p><p>I think the line between developer and environment is much more blurry than you are trying to make it. When I use a third-party asynchronous library that returns rejected promises, is that the developer or the environment? What about a third-party synchronous library that throws exceptions? If that third-party library returns a rejected promise, but I forget to observe rejection, this will cause the same problems that "forgetting" to wrap third-party library code in <code>try</code>/<code>catch</code> does. Yes, there is a difference, I admit: if your fulfillment handler does a <code>undefined.foo = "bar"</code>, that's clearly an environment-thrown exception. But you'd need another <code>try</code>/<code>catch</code> to handle that in a synchronous workflow (wherein it would be your <code>catch</code> block being boneheaded), so why the resistance to adding another rejection handler in an asynchronous one?</p><p>As for the silencing issue, I think you are referring to the problem wherein unobserved rejections that bubble all the way to the top need some way of making their presence known, just like unobserved exceptions do. This is solved in various ways by various promise libraries: in Q we have provided the <code>end</code> capping method [1] and, in master, a live console-list of unobserved rejections. In <a href="/wiki/WinJS">WinJS</a> promises (Windows 8's built-in promise framework for writing desktop apps) you can use an explicitly non-chaining <code>done</code> method, or a <code>WinJS.promise.onerror</code> handler. (Microsoft actually has a great article about this problem [3]—really highly recommended reading, although I know you are busy). From my understanding you find the tradeoff to be too great of a price to pay for the potential of lost exceptions, and that's fine. But it's a tradeoff that those using Promises/A promises have chosen to buy into.</p><p>[1]: <a href="http://documentup.com/kriskowal/q/#tutorial/the-end" class="ext-link"><span class="icon"></span>http://documentup.com/kriskowal/q/#tutorial/the-end</a></p><p>[2]: <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh701079.aspx" class="ext-link"><span class="icon"></span>http://msdn.microsoft.com/en-us/library/windows/apps/hh701079.aspx</a></p><p>[3]: <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh700337.aspx" class="ext-link"><span class="icon"></span>http://msdn.microsoft.com/en-us/library/windows/apps/hh700337.aspx</a></p><blockquote> That's complete bullshit. You WILL have a Deferred implementation as a dependency in your code.</blockquote><p>I really, strongly, disagree in the case of library authors. I think if you re-read what I was trying to say, this will become more clear. Deferreds are only necessary for adapting callback-style code. Once you have promises in your system, everything can be done with chaining in a library-agnostic way, which is why Promises/A is so powerful. I gave several examples of potential utility functions that promise-based libraries could provide. And of course I'll haul out Chai as Promised once again: it allows you to make assertions about the state of promises that then become promises, e.g.</p><pre class="wiki">
expect(promise).to.be.rejected.with(TypeError).then(
    function () {
        // promise was rejected with TypeError
    },
    function (err) {
        // err contains an AssertionError saying "expected TypeError but was WhateverError"
    }
);
assert.eventually.deepEqual(promise, { foo: { bar: "baz" } }).then(
    function () {
        // promise was fulfilled with something that was deepEqual to { foo: { bar: "baz" } }
    },
    function (err) {
        // err contains AssertionError.
    }
);
</pre><p>This is accomplished with zero dependency on a deferred library, and simply uses the <code>.then</code> function of whatever it is given. It has an extensive test suite that passes with Q promises, When.js promises, and <a href="/wiki/WinJS">WinJS</a> promises, but fails with jQuery promises even after s/<code>.then</code>/<code>.pipe</code>/g (and, from a glance, none of the failures are related to expected a <code>.promise</code> method).</p><blockquote> It should be perfectly interoperable.</blockquote><p>Your first rewritten example takes on a deferred dependency, so the returned promise will not be of the type passed in: now nobody wants to use my library, because they have to learn how to use Q promises when they were using <a href="/wiki/WinJS">WinJS</a> promises all along. Your second example will not work with any Promises/A compliant promises, since it returns the error instead of throwing it, thus causing the promise to be fulfilled (*now* we're swallowing exceptions :P). This is part of why I say that Promises/A has really thought this out: it's not easy to get such things right.</p><blockquote> I don't think Promise/A has been as carefully thought out as you try to make it sound: </blockquote><p>Promises/A is the minimal spec. Some of what you are referring to is addressed by Promises/B [4] or <a href="/wiki/UncommonJS">UncommonJS</a> promises [5]. Of course, neither of these specs have gotten much traction, because just getting people to agree to the basics of Promises/A is (1) hard enough; (2) powerful enough to enable interoperability.</p><p>[4]: <a href="http://wiki.commonjs.org/wiki/Promises/B" class="ext-link"><span class="icon"></span>http://wiki.commonjs.org/wiki/Promises/B</a></p><p>[5]: <a href="http://kriskowal.github.com/uncommonjs/promises/specification" class="ext-link"><span class="icon"></span>http://kriskowal.github.com/uncommonjs/promises/specification</a></p><p>Yes, Promises/A not perfect—especially if your priorities are not a direct synchronous-to-asynchronous correspondence—but I hope you can see why it has its proponents. If jQuery wants to go off in a different direction, that's fine, and I understand, but I just want to make sure I've helped you see the tradeoffs being made. It sounds like you are aware of most of them, and that jQuery intends to, in effect, cut itself off from the Promises/A ecosystem and encourage its own ecosystem, in which performance and never accidentally silencing exceptions are a higher priority than composability and interoperability.</p><p></p><hr><p></p><p>Thank you for your time, and sorry for making you read such a long treatise. As I said, promises are a passion of mine; I evangelize them heavily in the New York <a href="/wiki/JavaScript">JavaScript</a> community, and hate having to tell people to avoid jQuery promises when I do so. I hope I haven't exhausted your patience, and do appreciate that you're willing to engage with the Promises/A community like this.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:18">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 18, 2012 03:30PM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:18">comment:18</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>resolution:</th>
                  <td>
                    
                      <span class="change-field-new">→ fixed</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">open</span> → <span class="change-field-new">closed</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>summary:</th>
                  <td>
                    
                      <span class="change-field-old">Make Deferred implementation truly Promise/A compliant</span> → <span class="change-field-new">Make Deferred.then == Deferred.pipe like Promise/A</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I've retitled the ticket to describe its actual goal, which was accomplished here: <a href="https://github.com/jquery/jquery/commit/a41f2406748e3113751ab1e5b5d990d9144123fc" class="ext-link"><span class="icon"></span>https://github.com/jquery/jquery/commit/a41f2406748e3113751ab1e5b5d990d9144123fc</a></p><p>We cannot become compliant with other implementations of the interpretations of Promise/A without breaking a lot of existing jQuery user code. We do not want to do that. They will get mad and yell at us. Sorry.</p>
            </div>
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:19">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed June 18, 2012 03:58PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:19">comment:19</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Given the implementation is not Promise/A compatible, shouldn't we leave jQuery's Deferred.then as it is and go back to having pipe for chaining/filtering? Wouldn't it make sense not to introduce a breaking change for pretty much no benefit? This ticket was introduced and voted for on the assumption it would make our Promises "compliant enough" but it's not that simple... I'm on the road and cannot attend the meeting nor make the necessary changes but it would make sense and gibson is perfectly abke to do this if needs be.</p>
            </div>
          
        
      </div>
    </div>
  
</details>
</div>
        </div>
      </main>
      <footer>
        Copyright &copy; 2024
        <a href="https://openjsf.org">The OpenJS Foundation</a>
      </footer>
    </div>
    <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
  </body>
</html>
