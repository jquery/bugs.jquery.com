<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-pagefind-meta="title">#10811 ($.when provides incoherent arguments to .done() when called with multiple values) - jQuery - Bug Tracker</title>
    <meta name="description" content="Static archive of the old bugs.jquery.com Trac site.">
    
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="/bundle/SEeiGkT-TJ.css">
  </head>
  <body>
    <div class="banner flex-center">
      <span>jQuery issues have moved to <a href="https://github.com/jquery/jquery/issues">GitHub</a>. This site is now a static archive of the old <a href="https://trac.edgewall.org/">Trac</a> bugs site. Some functions and pages are no longer available.</span>
    </div>
    <div class="container">
      <a href="#skip" class="visually-hidden">Skip to main content</a>
      <header class="flex-column">
        <div class="flex-row flex-between-start">
          <a id="jq-siteLogo" href="/" title="jQuery Home">
            <img src="/img/logo.svg" width="215" alt="jQuery: Write Less, Do More.">
          </a>
          <input class="hamburger-toggle visually-hidden" id="jq-menutoggle" type="checkbox">
          <label aria-label="Toggle Menu" for="jq-menutoggle" class="hamburger-lines flex-column flex-between-center">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </label>
          <div id="jq-menus">
            <nav id="jq-primaryNavigation">
              <h2 class="visually-hidden">jQuery sites navigation menu</h2>
              <ul class="nav">
                <li class="jq-jquery active">
                  <a href="https://jquery.com/" title="jQuery Home">jQuery</a>
                </li>
                <li class="jq-plugins">
                  <a href="https://plugins.jquery.com/" title="jQuery Plugins">Plugins</a>
                </li>
                <li class="jq-ui">
                  <a href="https://jqueryui.com/" title="jQuery UI">UI</a>
                </li>
                <li class="jq-meetup">
                  <a href="https://meetups.jquery.com/" title="jQuery Meetups">Meetups</a>
                </li>
                <li class="jq-forum">
                  <a href="https://forum.jquery.com/" title="jQuery Forum">Forum</a>
                </li>
                <li class="jq-blog">
                  <a href="https://blog.jquery.com/" title="jQuery Blog">Blog</a>
                </li>
                <li class="jq-about">
                  <a href="https://openjsf.org" title="About jQuery and OpenJS">About</a>
                </li>
                <li class="jq-donate">
                  <a href="https://openjsf.org/about/project-funding-opportunities/" title="Donate to OpenJS">Donate</a>
                </li>
              </ul>
            </nav>
            <nav id="jq-secondaryNavigation">
              <h2 class="visually-hidden">jQuery Core navigation menu</h2>
              <ul class="nav">
                <li class="jq-download">
                  <a href="https://jquery.com/download/">
                    Download
                  </a>
                </li>
                <li class="jq-documentation">
                  <a href="https://api.jquery.com/">
                    Documentation
                  </a>
                </li>
                <li class="jq-tutorials">
                  <a href="https://learn.jquery.com/">
                    Tutorials
                  </a>
                </li>
                <li class="jq-bugTracker">
                  <a href="https://github.com/jquery/jquery/issues">
                    Bug Tracker
                  </a>
                </li>
                <li class="jq-discussion">
                  <a href="https://forum.jquery.com/">
                    Discussion
                  </a>
                </li>
              </ul>
            </nav>
          </div>
        </div>
        <div id="bug-tracker-form" class="flex-column flex-between-center">
          <h1>Bug Tracker</h1>
          <div id="search"></div>
          
        </div>
      </header>
      <main id="skip" class="flex-column">
        <h2 class="visually-hidden">Side navigation</h2>
        <nav id="jq-sidenav" class="flex-column white-box">
          <h5 class="sidenav-header">Bug Tracker</h5>
          <a href="/newticket">New Ticket</a>
          <a href="/report">View Tickets</a>
          <a href="/ticketgraph">Ticket Graph</a>
          <a href="/roadmap">Roadmap</a>
          <a href="/timeline">Recent Changes</a>
        </nav>
        <div id="jq-content" class="white-box">
          

<div class="flex-column" data-pagefind-body="">
  

  <nav class="content-nav">
    <ul class="flex-row">
      
        <li>
          <a href="/ticket/10810/">← Previous Ticket</a>
        
      
      
        </li><li>
          <a href="/ticket/10812/">Next Ticket →</a>
        </li>
      
    </ul>
  </nav>


<div class="ticket-info">
  <div class="flex-row flex-between-start">
    <h3>
      <a href="" class="ticket-number">#10811</a>
      <span class="ticket-status">closed</span>
      <span class="ticket-type">bug</span>
      <span class="ticket-resolution">(invalid)</span>
    </h3>

    <div class="ticket-dates">
      <p>Opened November 17, 2011 09:52AM UTC</p>
      
        <p>Closed November 17, 2011 01:22PM UTC</p>
      
      
        <p>Last modified August 21, 2012 04:27PM UTC</p>
      
    </div>
  </div>

  <h1 class="ticket-title">$.when provides incoherent arguments to .done() when called with multiple values</h1>

  <table class="ticket-properties">
    <tr>
      <th>Reported by:</th>
      <td>
        xmorel
      </td>
      <th>Owned by:</th>
      <td></td>
    </tr>
    <tr>
      <th>
        Priority:
      </th>
      <td>
        low
      </td>
      
        <th class="missing">Milestone:</th>
      
      <td>
        <a href="/milestone/None">None</a>
      </td>
    </tr>
    <tr>
      <th>Component:</th>
      <td>deferred</td>
      
        <th>Version:</th>
      
      <td>1.7</td>
    </tr>
    <tr>
      
        <th class="missing">Keywords:</th>
      
      <td></td>
      
        <th class="missing">Cc:</th>
      
      <td></td>
    </tr>
    <tr>
      <th class="missing">
        Blocked by:
      </th>
      <td></td>
      <th class="missing">
        Blocking:
      </th>
      <td></td>
    </tr>
  </table>
  <div class="ticket-info-bottom">
    <h5 class="ticket-description-title">Description</h5>
    <div class="ticket-description"><p>A single argument <code>$.when</code> forwards anything it got directly to its resolution (if the argument is a non-deferred it provides the non-deferred, if it's a deferred all values resolved by the deferred are resolved by the when), but it has a problematic inconsistency when used with multiple arguments:</p><ul><li>deferred resolving multiple values (e.g. jqxhr) result in <code>$.when</code> providing an array of these arguments to <code>.done()</code></li><li>non-deferred or deferred resolving a single value result in <code>$.when</code> providing the value as-is to its <code>.done()</code>, unwrapped</li><li>Deferred resolving to no value at all result in <code>$.when</code> providing <code>undefined</code> to its <code>.done()</code> (at least it's there)</li></ul><p>These changing behaviors make it extremely difficult to use <code>$.when</code> to correctly compose arbitrary deferreds (and values), especially if the deferred varies in the number of arguments it resolves, or if it can resolve arrays, or if the API (and thus the number of values resolved by the deferred) is still changing.</p><p>I think this should be changed in the following manner:</p><ul><li><code>$.when(arg)</code> stays unchanged, it's fine</li><li><code>$.when(arg+)</code> should result in **every** argument to <code>$.when</code> mapping to an **array** in the <code>.done()</code> callback:</li>  <li>A deferred resolving multiple values stays as-is (array of all parameters)</li>  <li>A value or a deferred resolving a single value **yields an array of a single value**</li>  <li>A deferred resolving no value **yields an empty array**</li></ul><p>This has two major advantages:</p><ul><li>Values resolved by <code>$.when</code> can be consistently sent to other functions (an other <code>$.when</code> or a <code>.resolve()</code> or <code>.resolveWith()</code> call), without wondering if this precise one need to be called via <code>.call()</code> or via <code>.apply()</code></li><li>changing number of values resolved by a deferred has a much lower influence on <code>$.when</code>'s result: if the <code>.done()</code> used the first value resolved it still does, whether the deferred resolves 1 or 17 values (of course if the deferred goes from 1 to 0 values resolved the code will break, but that's sensible I think)</li></ul><p>You can observe this behavior at <a href="http://jsfiddle.net/Xytms/1/:" class="ext-link"><span class="icon"></span>http://jsfiddle.net/Xytms/1/:</a></p><pre class="wiki">
$.when(novalue, onevalue).then(function () {
    console.log(arguments);
});
</pre><p>yields <code>[undefined, 1]</code>,</p><p>under this scheme it'd yield <code>[[], [1]]</code></p><pre class="wiki">
$.when(onevalue, twovalues, threevalues).then(function () {
    console.log(arguments);
});
</pre><p>yields <code>[1, [1, 2], [1, 2, 3]]</code>,</p><p>under this scheme it'd yield <code>[[1], [1, 2], [1, 2, 3]]</code></p><pre class="wiki">
$.when(null, 42, novalue, onevalue, twovalues).then(function () {
    console.log(arguments);
});
</pre><p>yields <code>[null, 42, undefined, 1, [1, 2]]</code>,</p><p>under this scheme it'd yield <code>[[null], [42], [], [1], [1, 2]]</code></p></div>
  </div>
</div>

<details>
  <summary class="ticket-details-summary">Attachments (0)</summary>

  <ul class="ticket-attachments">
    
  </ul>
</details>

<details open="">
  <summary class="ticket-details-summary">Change History (6)</summary>
  
    <div class="ticket-change flex-column" id="comment:1">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 17, 2011 01:22PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:1">comment:1</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>component:</th>
                  <td>
                    
                      <span class="change-field-old">unfiled</span> → <span class="change-field-new">deferred</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>priority:</th>
                  <td>
                    
                      <span class="change-field-old">undecided</span> → <span class="change-field-new">low</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>resolution:</th>
                  <td>
                    
                      <span class="change-field-new">→ invalid</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">closed</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>It seems to me you expect your Deferreds to always be resolved as an array so that you can use said value in an apply (I think we can agree it's quite a narrow use-case). It's easy enough to make sure the Promises provided to $.when always exhibit the behaviour you expect using pipe: <a href="http://jsfiddle.net/2ktvR/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/2ktvR/</a></p><p>Or better yet, have your Deferred resolve with a single array rather than multiple arguments and your problem will automagically disapear.</p><p>Current behaviour of $.when is there to make as much sense as possible in simple (and most common) use cases. That's why it will try and not wrap a single value into an array to make said value easier to access.</p>
            </div>
          
        
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:2">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 17, 2011 01:37PM UTC by <span class="author">xmorel</span></span>
        <a class="ticket-change-link" href="#comment:2">comment:2</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <blockquote> It seems to me you expect your Deferreds to always be resolved as an array</blockquote><p>No. All deferreds are resolved with parameters (0..n), and these parameters are an array. That's just a fact of life, that's pretty much what the <code>arguments</code> object is.</p><p>What I *would* expect is that $.when treats these arrays consistently, which it does not do (I outlined the cases). This has nothing to do with deferreds themselves, it has to do with $.when.</p><blockquote> It's easy enough to make sure the Promises provided to $.when always exhibit the behaviour you expect using pipe:  <a href="http://jsfiddle.net/2ktvR/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/2ktvR/</a></blockquote><p>This, however, require significant additional verbosity to make $.when simply coherent.</p><blockquote> Or better yet, have your Deferred resolve with a single array rather than multiple arguments and your problem will automagically disapear. </blockquote><p>I don't have control of all the deferreds I use. This simply is not an option.</p><p>Furthermore, it makes using the deferred raws much more complex, as one incurs a systematic indirection for little reason.</p><blockquote> Current behaviour of $.when is there to make as much sense as possible in simple (and most common) use cases. </blockquote><p>And that's the issue I have with it: the behavior makes sense when wrapping a single deferred or value ($.when acts as a simple proxy), but the incoherences are problematic when using $.when to multiplex deferreds, as each parameter of $.when can pretty arbitrarily vary between <code>undefined</code>, a single value (which may be an array) and an array of values with no indication of which is which.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:3">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 17, 2011 02:29PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:3">comment:3</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Replying to [comment:2 xmorel]:</p><blockquote> &gt; It's easy enough to make sure the Promises provided to $.when always exhibit the behaviour you expect using pipe:  <a href="http://jsfiddle.net/2ktvR/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/2ktvR/</a>  This, however, require significant additional verbosity to make $.when simply coherent.</blockquote><p>Here: <a href="http://jsfiddle.net/QA3xC/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/QA3xC/</a> verbosity gone (apart from the new when name of course).</p><blockquote> &gt; Or better yet, have your Deferred resolve with a single array rather than multiple arguments and your problem will automagically disapear.   I don't have control of all the deferreds I use. This simply is not an option.  Furthermore, it makes using the deferred raws much more complex, as one incurs a systematic indirection for little reason.</blockquote><p>Little reason being: make the most *common* use-case as easy and natural as possible. You are *not* the center of the universe, the millions of users joining two promises using $.when are.</p><blockquote> &gt; Current behaviour of $.when is there to make as much sense as possible in simple (and most common) use cases.   And that's the issue I have with it: the behavior makes sense when wrapping a single deferred or value ($.when acts as a simple proxy), but the incoherences are problematic when using $.when to multiplex deferreds, as each parameter of $.when can pretty arbitrarily vary between <code>undefined</code>, a single value (which may be an array) and an array of values with no indication of which is which.</blockquote><p>No, the behaviour makes sense when joining Deferreds too by not promoting a single resolve value that is not an array into an array just because it's "more consistent" (which it is not, it is just more convenient for your specific use-case).</p><p>Here is for consistency using your technique:</p><pre class="wiki">
    $.when( $.when( $.when( 6 ), $.when( "hello" ) ) ).done( function( a ) {
        // Do you expect a to be [ 6, "hello" ]
        // Or [ [ [ 6 ], [ "hello" ] ] ]?
        // Which one makes more sense and is easier to browse?
    });
</pre><p>If you think this is contrived, just imagine if the code providing you the Promise constructed it using $.when. You just replaced your 'not always an array problem' into 'an array of I-dunno-what-depth problem'.</p><p>Always wrapping into an array is simply not an option: it's no more consistent and exhibits far worse behaviours in complex scenarios.</p><p>Also, you have $.isArray to help you figure out what's going on and, yes, differentiating between a single resolve value that is an array and a list of arguments has been sacrificed here (again: keep things simple), but look at what $.when($.when(defer)) would yield with your solution and you'll see you're unable to make the distinction yourself.</p><p>If you're at a point where you need a specific format for the resolve values, maybe you'd better put on the social clothes and go and talk with the ones providing the Promises.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:4">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 17, 2011 03:11PM UTC by <span class="author">xmorel</span></span>
        <a class="ticket-change-link" href="#comment:4">comment:4</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
                <tr>
                  <th>_comment0:</th>
                  <td>
                    
                      <span class="change-field-old">&gt; Here:  http://jsfiddle.net/QA3xC/ verbosity gone (apart from the new when name of course). &#92;
&#92;
At this point, it would likely be simpler to just copy/paste `$.when`&#39;s code and remove the special case of unwrapping single values in multiple-argument when calls.&#92;
&#92;
&gt; No, the behaviour makes sense when joining Deferreds too by not promoting a single resolve value that is not an array into an array just because it&#39;s &quot;more consistent&quot;, which it is not&#92;
&#92;
Of course it is, deferred results are arrays, $.when with 2+ arguments currently unwraps some results, replaces others by a semi-arbitrary result and leaves a third-category alone. How can you argue this is more consistent than leaving the result of the deferreds alone in all cases?&#92;
&#92;
&gt; Here is for consistency using your technique: &#92;
&#92;
I see you have not actually read what I wrote&#92;
&#92;
&gt; If you think this is contrived&#92;
&#92;
It&#39;s not contrived, it&#39;s a misrepresentation. Which is worse.&#92;
&#92;
&gt; just imagine if the code providing you the Promise constructed it using $.when. You just replaced your &#39;not always an array problem&#39; into &#39;an array of I-dunno-what-depth problem&#39;. &#92;
&#92;
Again, you either have not bothered reading what I wrote and latched on a few parts you understood or you are wishfully mis-representing what I&#39;m suggesting.&#92;
&#92;
&gt; Always wrapping into an array&#92;
&#92;
The reality is that what I&#39;m suggesting actually aliases to *not unwrapping* values. There is a special case in $.when&#39;s handling of multiple arguments, removing it yields my suggestion.&#92;
&#92;
&gt; is simply not an option: it&#39;s no more consistent&#92;
&#92;
As previously noted, this declaration is obvious nonsense.&#92;
&#92;
&gt; and exhibits far worse behaviours in complex scenarios. &#92;
&#92;
The only scenario in which it exhibits &quot;far worse&quot; behavior is the multiplexing of a number of one-argument deferred **and only one-argument deferreds**. Which is a pretty simple scenario, and definitely not one I&#39;d expect to represent the majority of cases: most deferrer multiplexings would deal with synchronizing xhr requests (together or with an other event), which is *not* helped by the current behavior since jqxhr returns three arguments.&#92;
&#92;
In fact, at best the current behavior does not help and at worst it increases the cognitive load of the developer by forcing him to wonder, for every single deferred involved, if the deferred has one or more than one argument.&#92;
&#92;
&gt; Also, you have $.isArray to help you figure out what&#39;s going on and, yes, differentiating between a single resolve value that is an array and a list of arguments has been sacrificed here (again: keep things simple), but look at what $.when($.when(defer)) would yield with your solution and you&#39;ll see you&#39;re unable to make the distinction yourself. &#92;
&#92;
You are sadly wrong, and prove once more you have not read what I wrote. All along, my proposal has been to change the behavior of a multi-arguments `$.when` call. This is specified in the **first paragraph** of the report (and the `$.when` code already does the distinction and handles the two cases very differently).&#92;
&#92;
&gt; If you&#39;re at a point where you need a specific format for the resolve values, maybe you&#39;d better put on the social clothes and go and talk with the ones providing the Promises. &#92;
&#92;
And I&#39;d expect them to reply they&#39;re very sorry but they&#39;re not going  to make up crazy alternative protocols due to the inconsistencies of the jQuery API. And they&#39;d be right. They&#39;re not building their deferreds specifically for multiplexing via `$.when`.</span> → <span class="change-field-new">1321542704247749</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>_comment1:</th>
                  <td>
                    
                      <span class="change-field-old">&gt; Here:  http://jsfiddle.net/QA3xC/ verbosity gone (apart from the new when name of course). &#92;
&#92;
At this point, it would likely be simpler to just copy/paste `$.when`&#39;s code and remove the special case of unwrapping single values in multiple-argument when calls. It would also avoid the unwarranted snark.&#92;
&#92;
&gt; No, the behaviour makes sense when joining Deferreds too by not promoting a single resolve value that is not an array into an array just because it&#39;s &quot;more consistent&quot;, which it is not&#92;
&#92;
Of course it is, deferred results are arrays, $.when with 2+ arguments currently unwraps some results, replaces others by a semi-arbitrary result and leaves a third-category alone. How can you argue this is more consistent than leaving the result of the deferreds alone in all cases?&#92;
&#92;
&gt; Here is for consistency using your technique: &#92;
&#92;
I see you have not actually read what I wrote&#92;
&#92;
&gt; If you think this is contrived&#92;
&#92;
It&#39;s not contrived, it&#39;s a misrepresentation. Which is worse.&#92;
&#92;
&gt; just imagine if the code providing you the Promise constructed it using $.when. You just replaced your &#39;not always an array problem&#39; into &#39;an array of I-dunno-what-depth problem&#39;. &#92;
&#92;
Again, you either have not bothered reading what I wrote and latched on a few parts you understood or you are wishfully mis-representing what I&#39;m suggesting.&#92;
&#92;
&gt; Always wrapping into an array&#92;
&#92;
The reality is that what I&#39;m suggesting actually aliases to *not unwrapping* values. There is a special case in $.when&#39;s handling of multiple arguments, removing it yields my suggestion.&#92;
&#92;
&gt; is simply not an option: it&#39;s no more consistent&#92;
&#92;
As previously noted, this declaration is obvious nonsense.&#92;
&#92;
&gt; and exhibits far worse behaviours in complex scenarios. &#92;
&#92;
The only scenario in which it exhibits &quot;far worse&quot; behavior is the multiplexing of a number of one-argument deferred **and only one-argument deferreds**. Which is a pretty simple scenario, and definitely not one I&#39;d expect to represent the majority of cases: most deferrer multiplexings would deal with synchronizing xhr requests (together or with an other event), which is *not* helped by the current behavior since jqxhr returns three arguments.&#92;
&#92;
In fact, at best the current behavior does not help and at worst it increases the cognitive load of the developer by forcing him to wonder, for every single deferred involved, if the deferred has one or more than one argument.&#92;
&#92;
&gt; Also, you have $.isArray to help you figure out what&#39;s going on and, yes, differentiating between a single resolve value that is an array and a list of arguments has been sacrificed here (again: keep things simple), but look at what $.when($.when(defer)) would yield with your solution and you&#39;ll see you&#39;re unable to make the distinction yourself. &#92;
&#92;
You are sadly wrong, and prove once more you have not read what I wrote. All along, my proposal has been to change the behavior of a multi-arguments `$.when` call. This is specified in the **first paragraph** of the report (and the `$.when` code already does the distinction and handles the two cases very differently).&#92;
&#92;
&gt; If you&#39;re at a point where you need a specific format for the resolve values, maybe you&#39;d better put on the social clothes and go and talk with the ones providing the Promises. &#92;
&#92;
And I&#39;d expect them to reply they&#39;re very sorry but they&#39;re not going  to make up crazy alternative protocols due to the inconsistencies of the jQuery API. And they&#39;d be right. They&#39;re not building their deferreds specifically for multiplexing via `$.when`.</span> → <span class="change-field-new">1321542846186461</span>
                    
                  </td>
                </tr>
              
            
              
            
          </tbody>
        </table>
        
          
        
          
        
          
            <div class="ticket-comment-body">
              <blockquote> Here:  <a href="http://jsfiddle.net/QA3xC/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/QA3xC/</a> verbosity gone (apart from the new when name of course). </blockquote><p>At this point, it would likely be simpler to just copy/paste <code>$.when</code>'s code and remove the special case of unwrapping single values in multiple-argument when calls. It would also avoid the unwarranted snark.</p><blockquote> Little reason being: make the most *common* use-case as easy and natural as possible. You are *not* the center of the universe, the millions of users joining two promises using $.when are. </blockquote><p>I wouldn't expect those promises to usually be both 1-argument promise. Hence it would not be the common case. Would you care to provide support for your claims, or do you just claim to be The Voice Of Everybody?</p><blockquote> No, the behaviour makes sense when joining Deferreds too by not promoting a single resolve value that is not an array into an array just because it's "more consistent", which it is not</blockquote><p>Of course it is, deferred results are arrays, $.when with 2+ arguments currently unwraps some results, replaces others by a semi-arbitrary result and leaves a third-category alone. How can you argue this is more consistent than leaving the result of the deferreds alone in all cases?</p><blockquote> Here is for consistency using your technique: </blockquote><p>I see you have not actually read what I wrote</p><blockquote> If you think this is contrived</blockquote><p>It's not contrived, it's a misrepresentation. Which is worse.</p><blockquote> just imagine if the code providing you the Promise constructed it using $.when. You just replaced your 'not always an array problem' into 'an array of I-dunno-what-depth problem'. </blockquote><p>Again, you either have not bothered reading what I wrote and latched on a few parts you understood or you are wishfully mis-representing what I'm suggesting.</p><blockquote> Always wrapping into an array</blockquote><p>The reality is that what I'm suggesting actually aliases to *not unwrapping* values. There is a special case in $.when's handling of multiple arguments, removing it yields my suggestion.</p><blockquote> is simply not an option: it's no more consistent</blockquote><p>As previously noted, this declaration is obvious nonsense.</p><blockquote> and exhibits far worse behaviours in complex scenarios. </blockquote><p>The only scenario in which it exhibits "far worse" behavior is the multiplexing of a number of one-argument deferred **and only one-argument deferreds**. Which is a pretty simple scenario, and definitely not one I'd expect to represent the majority of cases: most deferrer multiplexings would deal with synchronizing xhr requests (together or with an other event), which is *not* helped by the current behavior since jqxhr returns three arguments.</p><p>In fact, at best the current behavior does not help and at worst it increases the cognitive load of the developer by forcing him to wonder, for every single deferred involved, if the deferred has one or more than one argument.</p><blockquote> Also, you have $.isArray to help you figure out what's going on and, yes, differentiating between a single resolve value that is an array and a list of arguments has been sacrificed here (again: keep things simple), but look at what $.when($.when(defer)) would yield with your solution and you'll see you're unable to make the distinction yourself. </blockquote><p>You are sadly wrong, and prove once more you have not read what I wrote. All along, my proposal has been to change the behavior of a multi-arguments <code>$.when</code> call. This is specified in the **first paragraph** of the report (and the <code>$.when</code> code already does the distinction and handles the two cases very differently).</p><blockquote> If you're at a point where you need a specific format for the resolve values, maybe you'd better put on the social clothes and go and talk with the ones providing the Promises. </blockquote><p>And I'd expect them to reply they're very sorry but they're not going  to make up crazy alternative protocols due to the inconsistencies of the jQuery API. And they'd be right. They're not building their deferreds specifically for multiplexing via <code>$.when</code>.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:5">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 17, 2011 04:21PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:5">comment:5</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
                <tr>
                  <th>_comment0:</th>
                  <td>
                    
                      <span class="change-field-old">{{{&#92;
function getInfos() {&#92;
    var promises = [];&#92;
    $.each( Array.prototype.slice.apply( arguments, 0 ), function( _, id ) {&#92;
        promises.push( $.ajax( &quot;myData?id=&quot; + id ).pipe(function( data ) {&#92;
            return data;&#92;
        }) );&#92;
    });&#92;
    return $.when.apply( $, promises );&#92;
}&#92;
&#92;
function getTemplates() {&#92;
    var promises = [];&#92;
    $.each( Array.prototype.slice.apply( arguments, 0 ), function( _, id ) {&#92;
        promises.push( $.ajax( &quot;myTemplate?id=&quot; + id ).pipe(function( data ) {&#92;
            return data;&#92;
        }) );&#92;
    });&#92;
    return $.when.apply( $, promises );&#92;
}&#92;
&#92;
$.when( getInfos( 1, 2 ), getTemplates( &quot;view&quot;, &quot;detail&quot; ) ).done(function( a, b ) {&#92;
    // Current behavior:&#92;
    // [ [ data1, data2 ], [ templateView, templateDetail ] ]&#92;
    // Your solution:&#92;
    // [ [ [ data1 ], [ data2 ] ], [ [ templateView ], [ templateDetail ] ] ]&#92;
});&#92;
&#92;
// Added &quot;noise&quot;/complexity with your solution:&#92;
&#92;
function deWrap() {&#92;
    var args = Array.prototype.slice.apply( arguments, 0 );&#92;
    if ( args.length ) {&#92;
        $.each( args, function( i, arg ) {&#92;
            args[ i ] = arg[ 0 ];&#92;
        });&#92;
    }&#92;
    return args;&#92;
}&#92;
&#92;
$.when(&#92;
    getInfos( 1, 2 ).pipe( deWrap ),&#92;
    getTemplates( &quot;view&quot;, &quot;detail&quot; ).pipe( deWrap )&#92;
).done(function( a, b ) {&#92;
    // That&#39;s provided getInfos and getTemplates&#92;
    // always return a promise&#92;
});&#92;
}}}&#92;
&#92;
Now, I use pipe after every ajax call because I don&#39;t want the code using my services to even know there&#39;s an ajax call involved. That way, I can easily code a fake/proxied method for testing purpose (or go get data from local storage, etc).&#92;
&#92;
Your approach makes using pipe a nightmare, now I still have to pipe after a call to $.when just to make sure nothing&#39;s autobadly wrapped into an array.&#92;
&#92;
So AGAIN, it&#39;s not more consistent, it&#39;s just a gigantic pain in the ass with piping acrobatics spreading all across the application, all that because YOU find it inconvenient to use $.isArray.&#92;
&#92;
(and I had hoped you would have been able to generalize from my one element examples since the fact your expected behaviour is different for a single arg makes your proposal so much worse I didn&#39;t even want to get into it)&#92;
&#92;
Now, feel free to discuss the example above at nauseum provided:&#92;
  1. you don&#39;t jump on implementation details as proof it is not a valid scenario because this or this or that: we both know we&#39;ll have contrived examples in posts in a bug tracker, bad faith is only good when it stops: the issue here is to know what happens when the promises you give to $.when are the output of previous calls to $.when (can we keep this civilized?)&#92;
  2. you stop paraphrasing &quot;you don&#39;t get it&quot; or &quot;you don&#39;t read&quot; as if they were arguments. I challenge you to provide code samples establishing your solution involves less work on the part of developpers in arbitrary situations where services can and will use $.when internally (maybe it&#39;s even the case in your specific use-case, have you checked with your co-workers?)&#92;
&#92;
Thank you.</span> → <span class="change-field-new">1321549119786913</span>
                    
                  </td>
                </tr>
              
            
              
            
          </tbody>
        </table>
        
          
        
          
            <div class="ticket-comment-body">
              <pre class="wiki">
function getInfos() {
    var promises = [];
    $.each( Array.prototype.slice.call( arguments, 0 ), function( _, id ) {
        promises.push( $.ajax( "myData?id=" + id ).pipe(function( data ) {
            return data;
        }) );
    });
    return $.when.apply( $, promises );
}

function getTemplates() {
    var promises = [];
    $.each( Array.prototype.slice.call( arguments, 0 ), function( _, id ) {
        promises.push( $.ajax( "myTemplate?id=" + id ).pipe(function( data ) {
            return data;
        }) );
    });
    return $.when.apply( $, promises );
}

$.when( getInfos( 1, 2 ), getTemplates( "view", "detail" ) ).done(function( a, b ) {
    // Current behavior:
    // [ [ data1, data2 ], [ templateView, templateDetail ] ]
    // Your solution:
    // [ [ [ data1 ], [ data2 ] ], [ [ templateView ], [ templateDetail ] ] ]
});

// Added "noise"/complexity with your solution:

function deWrap() {
    var args = Array.prototype.slice.call( arguments, 0 );
    if ( args.length ) {
        $.each( args, function( i, arg ) {
            args[ i ] = arg[ 0 ];
        });
    }
    return args;
}

$.when(
    getInfos( 1, 2 ).pipe( deWrap ),
    getTemplates( "view", "detail" ).pipe( deWrap )
).done(function( a, b ) {
    // That's provided getInfos and getTemplates
    // always return a promise
});
</pre><p>Now, I use pipe after every ajax call because I don't want the code using my services to even know there's an ajax call involved. That way, I can easily code a fake/proxied method for testing purpose (or go get data from local storage, etc).</p><p>Your approach makes using pipe a nightmare, now I still have to pipe after a call to $.when just to make sure nothing's autobadly wrapped into an array.</p><p>So AGAIN, it's not more consistent, it's just a gigantic pain in the ass with piping acrobatics spreading all across the application, all that because YOU find it inconvenient to use $.isArray.</p><p>(and I had hoped you would have been able to generalize from my one element examples since the fact your expected behaviour is different for a single arg makes your proposal so much worse I didn't even want to get into it)</p><p>Now, feel free to discuss the example above at nauseum provided:</p><p>  1. you don't jump on implementation details as proof it is not a valid scenario because this or this or that: we both know we'll have contrived examples in posts in a bug tracker, bad faith is only good when it stops: the issue here is to know what happens when the promises you give to $.when are the output of previous calls to $.when (can we keep this civilized?)</p><p>  2. you stop paraphrasing "you don't get it" or "you don't read" as if they were arguments. I challenge you to provide code samples establishing your solution involves less work on the part of developpers in arbitrary situations where services can and will use $.when internally (maybe it's even the case in your specific use-case, have you checked with your co-workers?)</p><p>Thank you.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:6">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed August 21, 2012 04:27PM UTC by <span class="author">mx4492@gmail.com</span></span>
        <a class="ticket-change-link" href="#comment:6">comment:6</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Related: <a href="http://stackoverflow.com/q/12050160/141220" class="ext-link"><span class="icon"></span>http://stackoverflow.com/q/12050160/141220</a></p>
            </div>
          
        
      </div>
    </div>
  
</details>
</div>
        </div>
      </main>
      <footer>
        Copyright &copy; 2024
        <a href="https://openjsf.org">The OpenJS Foundation</a>
      </footer>
    </div>
    <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
  </body>
</html>
