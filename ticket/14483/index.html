<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-pagefind-meta="title">#14483 (the promise of a promise is not the promise) - jQuery - Bug Tracker</title>
    <meta name="description" content="Static archive of the old bugs.jquery.com Trac site.">
    
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="/bundle/SEeiGkT-TJ.css">
  </head>
  <body>
    <div class="banner flex-center">
      <span>jQuery issues have moved to <a href="https://github.com/jquery/jquery/issues">GitHub</a>. This site is now a static archive of the old <a href="https://trac.edgewall.org/">Trac</a> bugs site. Some functions and pages are no longer available.</span>
    </div>
    <div class="container">
      <a href="#skip" class="visually-hidden">Skip to main content</a>
      <header class="flex-column">
        <div class="flex-row flex-between-start">
          <a id="jq-siteLogo" href="/" title="jQuery Home">
            <img src="/img/logo.svg" width="215" alt="jQuery: Write Less, Do More.">
          </a>
          <input class="hamburger-toggle visually-hidden" id="jq-menutoggle" type="checkbox">
          <label aria-label="Toggle Menu" for="jq-menutoggle" class="hamburger-lines flex-column flex-between-center">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </label>
          <div id="jq-menus">
            <nav id="jq-primaryNavigation">
              <h2 class="visually-hidden">jQuery sites navigation menu</h2>
              <ul class="nav">
                <li class="jq-jquery active">
                  <a href="https://jquery.com/" title="jQuery Home">jQuery</a>
                </li>
                <li class="jq-plugins">
                  <a href="https://plugins.jquery.com/" title="jQuery Plugins">Plugins</a>
                </li>
                <li class="jq-ui">
                  <a href="https://jqueryui.com/" title="jQuery UI">UI</a>
                </li>
                <li class="jq-meetup">
                  <a href="https://meetups.jquery.com/" title="jQuery Meetups">Meetups</a>
                </li>
                <li class="jq-forum">
                  <a href="https://forum.jquery.com/" title="jQuery Forum">Forum</a>
                </li>
                <li class="jq-blog">
                  <a href="https://blog.jquery.com/" title="jQuery Blog">Blog</a>
                </li>
                <li class="jq-about">
                  <a href="https://openjsf.org" title="About jQuery and OpenJS">About</a>
                </li>
                <li class="jq-donate">
                  <a href="https://openjsf.org/about/project-funding-opportunities/" title="Donate to OpenJS">Donate</a>
                </li>
              </ul>
            </nav>
            <nav id="jq-secondaryNavigation">
              <h2 class="visually-hidden">jQuery Core navigation menu</h2>
              <ul class="nav">
                <li class="jq-download">
                  <a href="https://jquery.com/download/">
                    Download
                  </a>
                </li>
                <li class="jq-documentation">
                  <a href="https://api.jquery.com/">
                    Documentation
                  </a>
                </li>
                <li class="jq-tutorials">
                  <a href="https://learn.jquery.com/">
                    Tutorials
                  </a>
                </li>
                <li class="jq-bugTracker">
                  <a href="https://github.com/jquery/jquery/issues">
                    Bug Tracker
                  </a>
                </li>
                <li class="jq-discussion">
                  <a href="https://forum.jquery.com/">
                    Discussion
                  </a>
                </li>
              </ul>
            </nav>
          </div>
        </div>
        <div id="bug-tracker-form" class="flex-column flex-between-center">
          <h1>Bug Tracker</h1>
          <div id="search"></div>
          
        </div>
      </header>
      <main id="skip" class="flex-column">
        <h2 class="visually-hidden">Side navigation</h2>
        <nav id="jq-sidenav" class="flex-column white-box">
          <h5 class="sidenav-header">Bug Tracker</h5>
          <a href="/newticket">New Ticket</a>
          <a href="/report">View Tickets</a>
          <a href="/ticketgraph">Ticket Graph</a>
          <a href="/roadmap">Roadmap</a>
          <a href="/timeline">Recent Changes</a>
        </nav>
        <div id="jq-content" class="white-box">
          

<div class="flex-column" data-pagefind-body="">
  

  <nav class="content-nav">
    <ul class="flex-row">
      
        <li>
          <a href="/ticket/14482/">← Previous Ticket</a>
        
      
      
        </li><li>
          <a href="/ticket/14484/">Next Ticket →</a>
        </li>
      
    </ul>
  </nav>


<div class="ticket-info">
  <div class="flex-row flex-between-start">
    <h3>
      <a href="" class="ticket-number">#14483</a>
      <span class="ticket-status">closed</span>
      <span class="ticket-type">bug</span>
      <span class="ticket-resolution">(notabug)</span>
    </h3>

    <div class="ticket-dates">
      <p>Opened October 24, 2013 07:27PM UTC</p>
      
        <p>Closed January 23, 2014 04:51PM UTC</p>
      
      
    </div>
  </div>

  <h1 class="ticket-title">the promise of a promise is not the promise</h1>

  <table class="ticket-properties">
    <tr>
      <th>Reported by:</th>
      <td>
        fastfasterfastest
      </td>
      <th>Owned by:</th>
      <td>fastfasterfastest</td>
    </tr>
    <tr>
      <th>
        Priority:
      </th>
      <td>
        low
      </td>
      
        <th class="missing">Milestone:</th>
      
      <td>
        <a href="/milestone/None">None</a>
      </td>
    </tr>
    <tr>
      <th>Component:</th>
      <td>deferred</td>
      
        <th>Version:</th>
      
      <td>1.10.2</td>
    </tr>
    <tr>
      
        <th class="missing">Keywords:</th>
      
      <td></td>
      
        <th class="missing">Cc:</th>
      
      <td></td>
    </tr>
    <tr>
      <th class="missing">
        Blocked by:
      </th>
      <td></td>
      <th class="missing">
        Blocking:
      </th>
      <td></td>
    </tr>
  </table>
  <div class="ticket-info-bottom">
    <h5 class="ticket-description-title">Description</h5>
    <div class="ticket-description"><p>The promise method of a promise should return the promise itself.</p><p>If a target is provided then deferred.promise(target) will attach the Promise aspect onto the target and return the target as the promise.  However, the promise method of that promise (the target object) does not return itself; instead it currently returns an "internal implementation object."</p><pre class="wiki">
var obj = { };

alert( $.Deferred().promise( obj ).promise() === obj ); //should be true
</pre><p>This can also be observed in the done, fail and notify callbacks - normally such callbacks are called with the promise as the context.  In the above case, when one has attached the promise of a deferred to an existing object, the done, fail and notify callbacks are called with the "internal implementation object" as a context, not the existing object (which is the promise) as expected.</p><pre class="wiki">
var obj = { },
   deferred = $.Deferred();

   //make obj the promise
   deferred.promise( obj );

   obj.done(function(){
      //context should be obj
      alert( this === obj );  //should be true
   });

   deferred.resolve();
</pre><p>Here is a fiddle demonstrating the issues: <a href="http://jsfiddle.net/fastfasterfastest/wKZrM/" class="ext-link"><span class="icon"></span>http://jsfiddle.net/fastfasterfastest/wKZrM/</a></p></div>
  </div>
</div>

<details>
  <summary class="ticket-details-summary">Attachments (0)</summary>

  <ul class="ticket-attachments">
    
  </ul>
</details>

<details open="">
  <summary class="ticket-details-summary">Change History (15)</summary>
  
    <div class="ticket-change flex-column" id="comment:1">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 24, 2013 08:51PM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:1">comment:1</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>component:</th>
                  <td>
                    
                      <span class="change-field-old">unfiled</span> → <span class="change-field-new">deferred</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>owner:</th>
                  <td>
                    
                      <span class="change-field-new">→ fastfasterfastest</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">pending</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Thanks for opening a ticket!</p><p>There are several reasons for the current behavior, not least of which is limiting method access to the promise's methods. As the docs explain, the user should maintain a reference to the deferred in order resolve/reject it later; it dissociates the deferred from its promise, which is good.</p><p>Please explain why someone might expect the behavior you've described. Use cases would be helpful.</p>
            </div>
          
        
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:2">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 24, 2013 08:55PM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:2">comment:2</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Also, I didn't make this clear, but it is better not to think of the <code>deferred.promise()</code> method as "making an object a promise" so much as adding promise behavior to an object. When you see it that way, I think you may understand why your illustrated conditions turn out to be false.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:3">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 24, 2013 10:10PM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:3">comment:3</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">pending</span> → <span class="change-field-new">new</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I don't see how the fact that the methods of a promise is a subset of its deferred has anything to do with the issue I am reporting.  Similarly, that the creator of a deferred typically holds on to the deferred so it can be resolved/rejected later, I don't think has anything to do with this.  Can you please explain how this comes into play here.</p><p>I think one might expect the behavior I describe for a couple of reasons - one is that is how "regular" promises work, another is the current documentation states that deferred.promise returns a deferred's promise object while returning the target object, and yet another is comments made by jaubourg (see <a href="https://github.com/jquery/api.jquery.com/issues/375)." class="ext-link"><span class="icon"></span>https://github.com/jquery/api.jquery.com/issues/375).</a></p><p>Either passing a target object to deferred.promise makes the target object a promise or not.</p><p>Currently, deferred.promise is documented as "return a Deferred's Promise object" and it returns the target object.  That seems to imply that the target object is "made into a promise."</p><p>If the intention is NOT to make the target object a promise but merely adding some promise-ish behavior to the target object, then a couple of things follow.</p><p>It means that to get to the real promise of the target object one must call the target object's promise method.</p><p>If one must call the target object's promise method to get to the promise, then there is no need to extend the target object with any of the "other promise methods" (done, fail, etc.) - it is sufficient to extend the target object with a promise method (since one must call it anyway to get to the promise.)</p><p>Furtermore, there is currently then a bug in deferred.promise when a target object is passed.  It currently returns the target object, but it should then instead return the target object's promise (i.e., the implementation should call promise() after extending the target object before returning.)</p><p>I think it comes down to having an in implementation that is consistent and can be documented.</p><p>Given the current implementation, behavior and documentation I assumed that calling deferred.promise indeed returns a promise and passing a target object makes that object a promise and returns it.</p><p>I came across this bug while starting to try to address some documentation bugs and omissions about deferred and promises, e.g. see <a href="https://github.com/jquery/api.jquery.com/issues/375" class="ext-link"><span class="icon"></span>https://github.com/jquery/api.jquery.com/issues/375</a></p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:4">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2013 02:06PM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:4">comment:4</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">pending</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I don't see why we can't have the cake. Wouldn't it suffice to simply change the description? Perhaps,</p><p>"Return a Deferred's Promise object or the target object when affixing promise behavior."</p><p>I think the rest of the docs expound on this behavior clearly:</p><blockquote> If target is provided, deferred.promise() will attach the methods onto it and then return this object rather than create a new one. This can be useful to attach the Promise behavior to an object that already exists.</blockquote><p>Regardless, you have not actually provided a use case.</p>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:5">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2013 07:51PM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:5">comment:5</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">pending</span> → <span class="change-field-new">new</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Yes, one way to fix a bug is to change the documentation so it corresponds with the behavior.</p><p>Another, is to change the behavior so it corresponds with the documentation, and if documentation is lacking or missing, with the intended behavior.</p><p>I have interpreted the intended behavior from existing behavior and from (somewhat lacking) documentation and from jaubourg's comments.  I think it makes sense for deferred.promise, when called with a target object, make the target object a promise.</p><p>If the intention is NOT to make the target object a promise, then why is the target object extended with</p><p>methods other than the promise method, e.g. done, fail, etc.?  The fact that the target object is extended with</p><p>those methods is further evidence that the intention is to make the target object a promise.</p><p>Perhaps/Hopefully jaubourg will chime in if he sees this ticket.</p><p>Even if the intention is NOT to make the target object a promise but merely adding some promise-ish behavior to the target object, then</p><p>as stated I think deferred.promise should still return a promise (it is simple enough, all it has to do is call promise() when it is returning),</p><p>and there is no need to change the documentation.</p><p>Why do you think it is better not to return a promise from a method that at all other times returns a promise, and is also named promise()?</p><p>With regard to use case - I had created minimal test cases to demonstrate the bug.  I thought that would be sufficient.</p><p>I have also mentioned consistency, which I think is important and a good thing and simplifies understanding for users.  "Regular" promises, those created and returned by calling deferred.promise() without passing an existing target object</p><p>behaves in a certain way.</p><p>It would be very good, for consistency and simplicity, to have promises that are created and </p><p>returned by calling deferred.promise(obj) and passing an existing target object behave the same way.</p><p>And I have pointed out two ways they do not and provided simple test cases for them.</p><p>I don't know how sophisticated of a use case you are asking for, but here is a simple one:</p><p>An existing object is set as promise.  When the associated deferred is resolved, any done callbacks are called with the promise/existing object as the context.</p><pre class="wiki">
// Existing object
var obj = {
    hello: function( name ) {
      alert( "Hello " + name );
    }
  },
  // Create a Deferred
  defer = $.Deferred();

// Set object as a promise
defer.promise( obj );

// Resolve the deferred
defer.resolve( "John" );

// Use the object as a Promise
obj.done(function( name ) {
  //currently break; context is not obj
  this.hello( name ); // Should alert "Hello John"
});
</pre>
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:6">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2013 07:58PM UTC by <span class="author">gibson042</span></span>
        <a class="ticket-change-link" href="#comment:6">comment:6</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I think this is a legitimate bug that we should fix.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:7">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2013 08:53PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:7">comment:7</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>This is working exactly as intended.</p><p>The use case here is to add a method to the Promise object. Amazingly, you can achieve that by adding a method to the Promise object:</p><pre class="wiki">defer.promise().hello = function( name ) {
  alert( "Hello " + name );
};

defer.resolve( "John" );

defer.done(function( name ) {
  this.hello( name ); // Alerts "Hello John"
});
</pre><p>Even if you wanted to do something more complex (like when you have a prototyped approach), you can use <code>resolveWith</code> to control which context is used:</p><pre class="wiki">function MyClass() {
}

MyClass.prototype = {
  hello: function( name ) {
    alert( "Hello " + name );
  }
};

defer.resolveWith( defer.promise( new MyClass() ), "John" );

defer.done(function( name ) {
  this.hello( name ); // Alerts "Hello John"
});
</pre><p>Keep in mind that the internal Promise object associated to a Deferred has to be the same object reference for the entire lifetime of the Deferred. The Promise is a public object that will be shared throughout your application, it has to always be the same reference or else you wouldn't be ensured that what you add on the Promise, method or attribute alike, would still be there at the time of resolution: another third-party could very well replace the Promise with another object.</p><p>Of course, the best, free of side-effects, approach is to create a separate object and set it as the context manually using resolveWith like shown above. But you still have use for additional data on the Promise object is not just for debugging purpose. It also doesn't kill that you can compare two promises using strict equality and know if they represent the same Task or not.</p><p>As to why the <code>promise( object )</code> returns the object and not the promise, it's so that litterals can be used. It is sane chaining that avoids dummy variable declarations:</p><pre class="wiki">// Current Behaviour
function addHello( defer ) {
  return defer.promise( {
    hello: function( name ) {
      alert( "Hello " + name );
    }
  } );
}

// Returning the promise instead
function addHello( defer ) {
  var obj = {
    hello: function( name ) {
      alert( "Hello " + name );
    }
  };
  defer.promise( obj );
  return obj;
}
</pre><p>So timmywil is right, we should ammend the documentation.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:8">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2013 10:13PM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:8">comment:8</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Ok.  So to summarize, this means that in the jquery deferred implementation</p><p>a promise is always the "internal implementation object".</p><p>A user cannot create or use his/her own object as a promise; the only way to get your hands on a promise object is to call deferred.promise() without a parameter.</p><p>So, we have three kinds of objects:</p><p>1. deferred object</p><p>   A deferred object is created and returned by $.Deferred().</p><p>2. promise object</p><p>   A promise object is returned by deferred.promise(), and promise.promise() - note, passing no parameters.</p><p>3. an object that has a promise method that returns a promise object</p><p>   An object that has a promise method that returns a promise object is typically a plain javascript object, created by the user, and then passed to deferred.promise(obj).  Such objects are not promise objects.</p><p>The documentation certainly needs to be updated to reflect this.  There are several places where it is either explicitly or implicitly stated that</p><p>one can make an existing object a promise by calling deferred.promise(obj).</p><p>Also, the documentation in several places currently states that objects should be a deferred or a promise,</p><p>when in fact they should be "an object that has a promise method that returns a promise object."</p><p>It would be great if there is a simple, usable term that could be used in the documentation for such objects, objects that has a promise method that returns a promise object.  Do you have any suggestion?</p><p>Jaouburg - why does deferred.promise(obj) extend the target object with methods other than promise(), e.g. done, fail, etc.?</p><p>I am not sure if it can be changed at this point for backward compatible reasons, but I think that</p><p>is confusing and gives users the impression that the obj has become a promise object, when in fact it has not.</p><p>It attaches the Promise methods to an object, but that object is still not a promise.</p><p>It merely has turned an object to "an object that has a promise method that returns a promise object".</p><p>&gt;another third-party could very well replace the Promise with another object</p><p>And you will have the same problem if you add methods to the system provided promise object, as in your first example.</p><p>A third-party could very well replace your methods, or you theirs.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:9">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 08, 2013 02:04PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:9">comment:9</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I think you're confusing THE promise associated with a Deferred instance with the notion of A promise.</p><p>Any object that implements the Promise interface is a Promise. It doesn't mean that it is THE promise associated to a specific Deferred instance.</p><p>Also...</p><blockquote> And you will have the same problem if you add methods to the system provided promise object, as in your first example. A third-party could very well replace your methods, or you theirs.</blockquote><p>There's a difference between some method/property name collision and the border effect of replacing an internal object.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:10">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 09, 2013 01:59AM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:10">comment:10</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>&gt;Any object that implements the Promise interface is a Promise.</p><p>Yes, but it is not sufficient to implement the methods of the Promise interface to qualify an object as a Promise - the methods also have to be implemented "correctly" according to the spec.</p><p>It has been stated:</p><p>1. the promise of a promise is the promise itself</p><p>2. calling deferred.promise(target) attaches the promise aspect to target</p><p>3. any object implementing the Promise interface is a Promise</p><p>So, after calling deferred.promise(target) one can deduce the following:</p><p>a. target implements the Promise interface (follows from 2)</p><p>b. target is A promise (follows from 3)</p><p>Thus, calling target.promise() should then return target itself (follows from 1).</p><p>But it does not.  So, something is not right.</p><p>Either 1, 2 and/or 3 is not correct, or the implementation is not correct, or a combination thereof.</p><p>There are issues in the current documentation compared to the current behavior and implementation.  I was going to try to correct the documentation and while doing so I came across this bug.</p><p>But if this turns out this is not a bug, it will be hard to correct the document in a straight-forward, clear and simple way - there are subtleties and inconsistencies in the current behavior and implementation.</p><p>I think the source of the issues might be the deferred.promise(target) and its attempt to do "too much", trying to make target a promise.</p><p>Perhaps deferred.promise shouldn't take any parameter.  Instead, there could be a deferred.observable(target) method which would make target "an observable through a promise" by adding only one method to target, .promise, which would return THE promise.  Note, it would not attach the whole promise aspect, only the "observable through a promise" aspect (a single .promise method).  Such a change would make it more explicit of the three kinds of objects involved.</p><p>Another idea might be that if you want to attach the promise aspect onto a target object you must supply the target when the deferred is created.</p><p>I.e., $.Deferred() could take an optional parameter, a target object, and</p><p>if supplied the promise interface will be attached to target and target will be THE Promise of the deferred.  If not supplied, $.Deferred creates an object to use as promise as today.  deferred.promise() would then no longer take any parameter.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:11">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 09, 2013 06:39PM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:11">comment:11</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>If the implementation of promise's promise method changed from</p><pre class="wiki">
promise: function( obj ) {
   return obj != null ? jQuery.extend( obj, promise ) : promise;
}
</pre><p>to</p><pre class="wiki">
promise: function( obj ) {
   return obj != null ? jQuery.extend( obj, promise ) : (this === deferred ? promise : this);
}
</pre><p>then I think the bug I reported would be fixed.  If a target is provided to deferred.promise() then that target would be made into a promise - it would implement the promise interface and it would return itself when calling its promise method.</p><p>The done, fail, notify callbacks of target, though, would still be called with the deferred's promise as the context, not the target itself.  Although unfortunate in my opinion, that can be clearly documented.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:12">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed November 12, 2013 01:23AM UTC by <span class="author">fastfasterfastest</span></span>
        <a class="ticket-change-link" href="#comment:12">comment:12</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>@Jaubourg - on a somewhat related topic, the implementation of deferred's resolve, reject and notify methods (line 3305 in <a href="http://code.jquery.com/jquery-git1.js):" class="ext-link"><span class="icon"></span>http://code.jquery.com/jquery-git1.js):</a></p><pre class="wiki">
deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
</pre><p>I don't know all the intricacies of the implementation, but can the context ever be anything other than deferred?  If not, that could be simplified to:</p><pre class="wiki">
deferred[ tuple[0] + "With" ]( promise, arguments );
</pre><p>And, even if the context can be something other than the deferred, shouldn't the callbacks be fired with the deferred's promise as the context anyway?</p><p>Unfortunately I am not set up to run the unit tests here, so I cannot test that.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:13">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed January 23, 2014 04:17PM UTC by <span class="author">timmywil</span></span>
        <a class="ticket-change-link" href="#comment:13">comment:13</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>priority:</th>
                  <td>
                    
                      <span class="change-field-old">undecided</span> → <span class="change-field-new">low</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">pending</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Let's break it down. What is the final proposal here? Keep in mind that we're probably not going to gut the Deferred implementation.</p>
            </div>
          
        
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:14">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed January 23, 2014 04:48PM UTC by <span class="author">jaubourg</span></span>
        <a class="ticket-change-link" href="#comment:14">comment:14</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I still don't see any use-case that is not covered by the existing implementation as is. I explained why earlier. We should close this.</p>
            </div>
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:15">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed January 23, 2014 04:51PM UTC by <span class="author">dmethvin</span></span>
        <a class="ticket-change-link" href="#comment:15">comment:15</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>resolution:</th>
                  <td>
                    
                      <span class="change-field-new">→ notabug</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">pending</span> → <span class="change-field-new">closed</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>I think we should leave our existing implementation alone and not change its behavior. We already have a Promise discussion on the list for San Diego.</p>
            </div>
          
        
          
        
          
        
      </div>
    </div>
  
</details>
</div>
        </div>
      </main>
      <footer>
        Copyright &copy; 2024
        <a href="https://openjsf.org">The OpenJS Foundation</a>
      </footer>
    </div>
    <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
  </body>
</html>
